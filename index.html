
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Royalties Dashboard — Multi‑View (v15: ASCAP Intl detection)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        :root {
            --bg: radial-gradient(115% 140% at 15% 10%, #253450 0%, #121b2d 45%, #060910 100%);
            --bg-secondary: radial-gradient(90% 110% at 80% 20%, rgba(92, 173, 255, 0.22) 0%, rgba(3, 9, 20, 0) 65%);
            --card: rgba(16, 25, 43, 0.72);
            --card-strong: rgba(24, 36, 56, 0.82);
            --border: rgba(163, 184, 255, 0.24);
            --muted: rgba(209, 220, 243, 0.72);
            --text: #f1f7ff;
            --accent: #7CF1B4;
            --accent-soft: rgba(124, 241, 180, 0.25);
            --shadow: 0 30px 70px rgba(5, 10, 25, 0.55);
            font-family: "Inter", -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background: var(--bg-secondary);
            z-index: -1;
        }

        .app {
            max-width: 1280px;
            margin: 0 auto;
            padding: 32px 24px 48px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .top {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 28px 32px;
            border-radius: 22px;
            background: linear-gradient(160deg, rgba(32, 44, 72, 0.88), rgba(10, 18, 34, 0.72));
            border: 1px solid rgba(160, 195, 255, 0.22);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .top::after {
            content: "";
            position: absolute;
            width: 320px;
            height: 320px;
            background: radial-gradient(circle at center, rgba(124, 241, 180, 0.35) 0%, rgba(124, 241, 180, 0) 70%);
            top: -160px;
            right: -60px;
            pointer-events: none;
            filter: blur(4px);
        }

        .logo {
            width: 64px;
            height: 64px;
            border-radius: 18px;
            background: linear-gradient(135deg, rgba(124, 241, 180, 0.4), rgba(124, 241, 180, 0.1));
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(12px);
            border: 1px solid rgba(124, 241, 180, 0.45);
            box-shadow: 0 18px 30px rgba(0, 0, 0, 0.35);
        }

        .logo svg {
            transform: scale(1.05);
        }

        h1 {
            margin: 0 0 6px 0;
            font-size: 1.65rem;
            letter-spacing: -0.01em;
        }

        .subhead {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
            color: var(--muted);
        }

        .version-chip {
            display: inline-flex;
            align-items: center;
            padding: 2px 10px;
            border-radius: 999px;
            border: 1px solid rgba(124, 241, 180, 0.35);
            background: var(--accent-soft);
            color: #0f261c;
            font-weight: 600;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            font-size: 0.7rem;
        }

        .controls {
            margin-left: auto;
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .view-tabs {
            display: flex;
            gap: 8px;
            background: rgba(9, 18, 36, 0.6);
            border-radius: 14px;
            padding: 6px;
            border: 1px solid rgba(146, 192, 255, 0.24);
            backdrop-filter: blur(12px);
        }

        .file-btn,
        .nav-btn {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            padding: 10px 16px;
            border-radius: 12px;
            border: 1px solid transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.92rem;
            letter-spacing: 0.01em;
            transition: all 0.18s ease-in-out;
        }

        .file-btn {
            background: linear-gradient(135deg, #92ddff, #5ae9c5);
            color: #042536;
            box-shadow: 0 18px 35px rgba(19, 104, 151, 0.35);
        }

        .file-btn:hover {
            filter: brightness(1.05);
            box-shadow: 0 20px 38px rgba(19, 104, 151, 0.45);
        }

        .nav-btn {
            background: transparent;
            color: var(--muted);
            border: 1px solid rgba(165, 190, 255, 0.2);
            box-shadow: none;
        }

        .nav-btn:hover,
        .nav-btn:focus {
            color: var(--text);
            border-color: rgba(124, 241, 180, 0.45);
            background: rgba(124, 241, 180, 0.12);
        }

        .nav-btn.is-active {
            color: var(--text);
            border-color: rgba(124, 241, 180, 0.6);
            background: rgba(124, 241, 180, 0.24);
            box-shadow: 0 12px 26px rgba(16, 48, 36, 0.35);
        }

        .nav-btn.ghost {
            border-color: rgba(165, 190, 255, 0.12);
            background: rgba(14, 24, 46, 0.6);
        }

        .nav-btn.ghost:hover,
        .nav-btn.ghost:focus {
            background: rgba(124, 241, 180, 0.18);
        }

        .muted {
            padding: 9px 14px;
            border-radius: 10px;
            border: 1px solid rgba(163, 184, 255, 0.3);
            background: rgba(10, 20, 38, 0.6);
            color: var(--muted);
            cursor: pointer;
            transition: all 0.18s ease-in-out;
        }

        .muted:hover,
        .muted:focus {
            color: var(--text);
            border-color: rgba(124, 241, 180, 0.4);
            background: rgba(124, 241, 180, 0.16);
        }

        .card {
            padding: 24px 28px;
            border-radius: 20px;
            background: var(--card);
            border: 1px solid rgba(150, 180, 255, 0.2);
            backdrop-filter: blur(18px);
            box-shadow: var(--shadow);
        }

        .card h3 {
            font-weight: 600;
            font-size: 1.2rem;
        }

        .small {
            font-size: 0.9rem;
            color: var(--muted);
        }

        .views {
            display: none;
            margin-top: 12px;
        }

        .views.active {
            display: block;
        }

        .landing-grid {
            margin-top: 18px;
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            gap: 18px;
        }

        .landing-card {
            grid-column: span 6;
            background: var(--card-strong);
            border: 1px solid rgba(160, 195, 255, 0.25);
            border-radius: 18px;
            padding: 22px 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 20px 48px rgba(6, 12, 30, 0.35);
        }

        .landing-card.full-span {
            grid-column: span 12;
        }

        .landing-card h4 {
            margin: 0;
            font-size: 1.05rem;
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        .insight-list {
            margin: 0;
            padding: 0;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .insight-pill {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(146, 192, 255, 0.12);
            border: 1px solid rgba(146, 192, 255, 0.22);
            font-weight: 600;
            font-size: 0.95rem;
        }

        .insight-pill .muted {
            font-weight: 500;
        }

        .insight-metric {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .insight-metric .label {
            font-size: 0.82rem;
            color: rgba(209, 220, 243, 0.75);
        }

        .insight-metric .value {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .insight-note {
            margin-top: 2px;
        }

        .full {
            height: 620px;
            border-radius: 14px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(9, 15, 30, 0));
            overflow: hidden;
            padding: 10px;
            border: 1px solid rgba(120, 156, 255, 0.15);
        }

        .diagnostics-wrapper {
            display: flex;
            flex-direction: column;
            gap: 14px;
            margin-top: 10px;
        }

        .diagnostics-entry {
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 14px;
            padding: 14px 16px 18px;
            background: rgba(12, 20, 36, 0.55);
            box-shadow: 0 12px 30px rgba(4, 8, 20, 0.35);
        }

        .diagnostics-entry header {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: space-between;
            align-items: baseline;
        }

        .diagnostics-entry header .meta {
            font-size: 0.85rem;
            color: rgba(209, 220, 243, 0.8);
        }

        .diagnostics-entry header strong {
            font-size: 1rem;
        }

        .diagnostics-grid {
            margin-top: 14px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
            gap: 12px;
        }

        .diagnostics-grid label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.8rem;
            color: rgba(209, 220, 243, 0.72);
        }

        .diag-select {
            border-radius: 10px;
            border: 1px solid rgba(160, 195, 255, 0.28);
            background: rgba(8, 14, 26, 0.65);
            color: var(--text);
            padding: 8px 10px;
            font-size: 0.9rem;
        }

        .diagnostics-actions {
            margin-top: 16px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .diagnostics-empty {
            padding: 18px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed rgba(146, 192, 255, 0.35);
        }

        .diagnostics-note {
            margin-top: 4px;
            font-size: 0.78rem;
            color: rgba(209, 220, 243, 0.68);
        }

        #bottomOverview {
            margin-top: 6px;
            padding: 26px 28px;
            border-radius: 20px;
            background: var(--card-strong);
            border: 1px solid rgba(150, 180, 255, 0.24);
            box-shadow: var(--shadow);
        }

        #bottomOverview h3 {
            margin: 0;
        }

        #bottomOverview.hidden {
            display: none;
        }

        .rev-controls,
        .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            padding: 8px 12px;
            border-radius: 12px;
            background: rgba(12, 22, 44, 0.45);
            border: 1px solid rgba(146, 192, 255, 0.2);
        }

        input.small-input,
        select.small-input,
        .muted,
        .nav-btn,
        .file-btn {
            font-family: inherit;
        }

        input.small-input,
        select.small-input {
            background: rgba(8, 16, 32, 0.6);
            border: 1px solid rgba(140, 170, 255, 0.3);
            padding: 7px 10px;
            border-radius: 10px;
            color: var(--text);
            transition: border-color 0.18s ease-in-out, box-shadow 0.18s ease-in-out;
        }

        input.small-input:focus,
        select.small-input:focus {
            border-color: rgba(124, 241, 180, 0.6);
            box-shadow: 0 0 0 3px rgba(124, 241, 180, 0.18);
            outline: none;
        }

        label.inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .kpi-grid {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .kpi-card {
            padding: 16px 20px;
            min-width: 190px;
            border-radius: 16px;
            background: rgba(14, 24, 46, 0.7);
            border: 1px solid rgba(150, 180, 255, 0.28);
            box-shadow: 0 18px 38px rgba(4, 10, 26, 0.45);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .kpi-card.is-wide {
            min-width: 240px;
        }

        .kpi-label {
            text-transform: uppercase;
            font-size: 0.72rem;
            letter-spacing: 0.12em;
            color: rgba(198, 213, 240, 0.7);
        }

        .kpi-value {
            font-size: 1.35rem;
            font-weight: 700;
        }

        .kpi-value.is-compact {
            font-size: 1rem;
            line-height: 1.4;
        }

        .bottom-layout {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 24px;
            flex-wrap: wrap;
        }

        .bottom-diagnostics {
            min-width: 320px;
            max-width: 620px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .rate-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        #fileList {
            min-height: 54px;
        }

        a {
            color: var(--accent);
        }

        @media (max-width: 900px) {
            .top {
                flex-direction: column;
                align-items: flex-start;
                gap: 24px;
            }

            .controls {
                width: 100%;
                flex-direction: column;
                align-items: stretch;
            }

            .view-tabs {
                width: 100%;
                justify-content: space-between;
                flex-wrap: wrap;
            }

            .nav-btn {
                flex: 1 1 45%;
                justify-content: center;
            }

            .full {
                height: 420px;
            }

            .bottom-layout {
                flex-direction: column;
            }
        }

        @media (max-width: 1080px) {
            .landing-card {
                grid-column: span 12;
            }
        }

        @media (max-width: 720px) {
            .landing-grid {
                grid-template-columns: repeat(6, minmax(0, 1fr));
            }

            .landing-card {
                grid-column: span 6;
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <div class="top">
            <div class="logo"><svg width="28" height="28" viewBox="0 0 24 24" fill="none">
                    <rect x="2" y="2" width="20" height="20" rx="6" fill="#9EF09E"></rect>
                    <path d="M7 14.5L10.5 10L13 13.5L17 8" stroke="#fff" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" />
                </svg></div>
            <div>
                <h1>Royalties Dashboard</h1>
                <div class="subhead"><span class="version-chip">v15</span></div>
            </div>

            <div class="controls">
                <label class="file-btn" id="csvLabel">
                    <input id="csvInput" type="file" accept=".csv,text/csv" multiple style="display:none" />
                    Upload CSVs
                </label>
                <div class="view-tabs">
                    <button id="landingBtn" class="nav-btn">Landing</button>
                    <button id="tsBtn" class="nav-btn">Time series</button>
                    <button id="cumBtn" class="nav-btn">Cumulative</button>
                    <button id="workIncomeBtn" class="nav-btn">Work Income</button>
                    <button id="topBtn" class="nav-btn">Top works</button>
                    <button id="revBtn" class="nav-btn">Revenue classes</button>
                </div>
            </div>
        </div>

        <div id="landingView" class="card views active">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <div>
                    <h3 style="margin:0">Overview</h3>
                    <div class="small">Upload royalty statements to populate the dashboard views.</div>
                </div>
            </div>
            <div id="landingInsights" class="landing-grid">
                <div class="landing-card full-span">
                    <h4>Load your royalty statements</h4>
                    <div class="small">Upload SGAE, ASCAP, or Warner Chappell CSV files to unlock highlights, trends, and diagnostics.</div>
                    <div class="insight-note small">Once data is loaded you will see provider mix, latest quarter performance, and data health here.</div>
                </div>
            </div>
        </div>

        <div id="tsView" class="card views">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <div>
                    <h3 style="margin:0">Net income over time — by provider</h3>
                    <div class="small">Choose between separate lines or stacked area (stacked lines).</div>
                </div>
                <div class="chart-controls">
                    <label class="inline small">Chart:
                        <select id="tsChartType" class="small-input">
                            <option value="lines">Separate lines</option>
                            <option value="stacked">Stacked area</option>
                        </select>
                    </label>
                    <label class="inline small"><input id="tsHideOther" type="checkbox" /> Hide "Other"</label>
                    <button id="downloadTS" class="muted">Download PNG</button>
                    <button class="back-btn nav-btn ghost" data-target="landingView">Back</button>
                </div>
            </div>
            <div id="timeSeriesFull" class="full"></div>
        </div>

        <div id="cumView" class="card views">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <div>
                    <h3 style="margin:0">Cumulative income — by provider</h3>
                    <div class="small">Cumulative sum per provider. Can be shown as separate cumulative lines or stacked cumulative area.</div>
                </div>
                <div class="chart-controls">
                    <label class="inline small">Chart:
                        <select id="cumChartType" class="small-input">
                            <option value="lines">Separate lines</option>
                            <option value="stacked">Stacked area</option>
                        </select>
                    </label>
                    <label class="inline small"><input id="cumHideOther" type="checkbox" /> Hide "Other"</label>
                    <button id="downloadCum" class="muted">Download PNG</button>
                    <button class="back-btn nav-btn ghost" data-target="landingView">Back</button>
                </div>
            </div>
            <div id="cumulativeFull" class="full"></div>
        </div>

        <div id="workIncomeView" class="card views">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                <div>
                    <h3 style="margin:0">Work income over time</h3>
                    <div class="small">Select a work to see quarterly income with options for actual or cumulative totals.</div>
                </div>
                <div class="chart-controls">
                    <label class="inline small">Work:
                        <select id="workIncomeSelect" class="small-input" style="min-width:200px"></select>
                    </label>
                    <label class="inline small">View:
                        <select id="workIncomeMode" class="small-input">
                            <option value="series">Time series</option>
                            <option value="cumulative">Cumulative</option>
                        </select>
                    </label>
                    <button id="downloadWorkIncome" class="muted">Download PNG</button>
                    <button class="back-btn nav-btn ghost" data-target="landingView">Back</button>
                </div>
            </div>
            <div id="workIncomeChart" class="full"></div>
        </div>

        <div id="topView" class="card views">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <div>
                    <h3 style="margin:0">Top works by income (Top 10)</h3>
                    <div class="small">Click bar to focus a work.</div>
                </div>
                <div>
                    <button id="downloadTop" class="muted">Download PNG</button>
                    <button class="back-btn nav-btn ghost" data-target="landingView">Back</button>
                </div>
            </div>
            <div id="topWorksFull" class="full"></div>
        </div>

        <div id="revView" class="card views">
            <div style="display:flex;justify-content:space-between;align-items:center">
                <div>
                    <h3 style="margin:0">Revenue class breakdown (stacked)</h3>
                    <div class="small">Stacked bars across quarters — blends <strong>DESCRIP. CONCEP</strong>, <strong>Revenue Class Description</strong>, and <strong>Music User Genre</strong>.</div>
                </div>
                <div class="rev-controls">
                    <select id="revQuarterSelect" class="small-input" style="min-width:140px"></select>
                    <button id="downloadRev" class="muted">Download PNG</button>
                    <button class="back-btn nav-btn ghost" data-target="landingView">Back</button>
                </div>
            </div>
            <div id="revFull" class="full"></div>
        </div>

        <div id="bottomOverview" class="card">
            <div class="bottom-layout">
                <div id="kpiTiles"></div>
                <div class="bottom-diagnostics">
                    <h3>Diagnostics &amp; Mappings</h3>
                    <div id="fileList" class="diagnostics-wrapper small">
                        <div class="diagnostics-empty">No files loaded yet. Upload statements to review detected mappings.</div>
                    </div>
                    <div class="diagnostics-note">Refine gross, deduction, and period mappings per file. Changes recalculate the entire dashboard instantly.</div>
                    <div class="rate-controls">
                        <label class="small">EUR → USD (manual):</label>
                        <input id="manualRate" class="small-input" placeholder="leave blank or e.g., EUR=1.1" />
                        <button id="applyRate" class="muted">Apply</button>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        /* v14: Limit Top Works view to top 10 items for clarity.
   Only change: renderTopWorksFull now uses topN = 10.
*/ // Set default chart types to stacked area

        const timeSeriesEl = document.getElementById('timeSeriesFull');
        const cumulativeEl = document.getElementById('cumulativeFull');
        const topWorksEl = document.getElementById('topWorksFull');
        const revenueStackEl = document.getElementById('revFull');
        const bottomOverviewEl = document.getElementById('bottomOverview');
        const tsChartTypeEl = document.getElementById('tsChartType');
        const tsHideOtherEl = document.getElementById('tsHideOther');
        const cumChartTypeEl = document.getElementById('cumChartType');
        const cumHideOtherEl = document.getElementById('cumHideOther');
        const manualRateInput = document.getElementById('manualRate');
        const applyRateBtn = document.getElementById('applyRate');
        const revQuarterSelectEl = document.getElementById('revQuarterSelect');

        if (cumChartTypeEl) {
            cumChartTypeEl.value = 'stacked';
        }
        const initialTsSelect = tsChartTypeEl || document.getElementById('chartType');
        if (initialTsSelect) {
            initialTsSelect.value = 'stacked';
        }

        const csvInput = document.getElementById('csvInput');
        csvInput.addEventListener('change', handleCsvFiles);
        document.getElementById('csvLabel').addEventListener('click', () => csvInput.click());

        let rawDataRows = [];
        let normalized = [];
        let fileDiagnostics = [];
        let providerAggregationCache = null;
        let providerAggregationDirty = true;
        let revenueTableCache = null;
        let revenueTableDirty = true;
        const liveRates = {
            EUR: null,
            COP: null
        };
        const manualRates = {
            EUR: null,
            COP: null
        };

        const SGAE_HEADERS = {
            WORK_TITLE: 'TIT. OBRA MUSICAL',
            PERIOD: 'PERIODO ORIGEN',
            DEDUCTION: 'DTO. ADMINISTRACION',
            GROSS: 'IMPORTE'
        };

        const FALLBACK_RATES = {
            EUR: 1.0,
            COP: 0.00025
        };

        const views = ['landingView', 'tsView', 'cumView', 'workIncomeView', 'topView', 'revView'];
        const viewElements = Object.fromEntries(views.map(id => [id, document.getElementById(id)]));
        const navButtons = {
            landingView: document.getElementById('landingBtn'),
            tsView: document.getElementById('tsBtn'),
            cumView: document.getElementById('cumBtn'),
            workIncomeView: document.getElementById('workIncomeBtn'),
            topView: document.getElementById('topBtn'),
            revView: document.getElementById('revBtn')
        };
        if (navButtons.landingView) navButtons.landingView.classList.add('is-active');
        document.getElementById('landingBtn').addEventListener('click', () => showView('landingView'));
        document.getElementById('tsBtn').addEventListener('click', () => showView('tsView'));
        document.getElementById('cumBtn').addEventListener('click', () => showView('cumView'));
        document.getElementById('workIncomeBtn').addEventListener('click', () => showView('workIncomeView'));
        document.getElementById('topBtn').addEventListener('click', () => showView('topView'));
        document.getElementById('revBtn').addEventListener('click', () => showView('revView'));
        document.querySelectorAll('.back-btn').forEach(b => b.addEventListener('click', (e) => {
            const t = e.currentTarget.dataset.target || 'landingView';
            showView(t);
        }));

        const workIncomeSelectEl = document.getElementById('workIncomeSelect');
        const workIncomeModeEl = document.getElementById('workIncomeMode');
        const workIncomeChartEl = document.getElementById('workIncomeChart');
        const downloadWorkIncomeBtn = document.getElementById('downloadWorkIncome');
        let currentWorkIncomeWork = null;
        const workIncomeCache = new Map();
        let workIncomeCacheDirty = true;

        if (workIncomeModeEl) {
            workIncomeModeEl.value = 'series';
        }

        if (downloadWorkIncomeBtn) {
            downloadWorkIncomeBtn.disabled = true;
        }

        if (workIncomeSelectEl) {
            workIncomeSelectEl.addEventListener('change', () => {
                currentWorkIncomeWork = workIncomeSelectEl.value;
                renderWorkIncomeChart();
            });
        }

        if (workIncomeModeEl) {
            workIncomeModeEl.addEventListener('change', () => {
                renderWorkIncomeChart();
            });
        }

        // re-render on control change for immediate feedback
        if (tsChartTypeEl) {
            tsChartTypeEl.addEventListener('change', () => {
                if (isViewActive('tsView')) renderTimeSeriesByProvider();
            });
        }
        if (tsHideOtherEl) {
            tsHideOtherEl.addEventListener('change', () => {
                if (isViewActive('tsView')) renderTimeSeriesByProvider();
            });
        }
        if (cumChartTypeEl) {
            cumChartTypeEl.addEventListener('change', () => {
                if (isViewActive('cumView')) renderCumulativeByProvider();
            });
        }
        if (cumHideOtherEl) {
            cumHideOtherEl.addEventListener('change', () => {
                if (isViewActive('cumView')) renderCumulativeByProvider();
            });
        }

        if (applyRateBtn) applyRateBtn.addEventListener('click', () => {
            const raw = manualRateInput ? manualRateInput.value.trim() : '';
            if (raw === '') {
                manualRates.EUR = null;
                manualRates.COP = null;
                alert('Manual overrides cleared — will use live rates if available.');
                convertCurrenciesToUSD().then(() => refreshVisualsAfterConversion());
                return;
            }
            const parts = raw.split(/[;,]/).map(p => p.trim()).filter(Boolean);
            if (!parts.length) parts.push(raw);
            let applied = false;
            for (const part of parts) {
                const autoMatch = part.match(/^([A-Za-z]{3})\s*=\s*(auto)$/i);
                if (autoMatch) {
                    const code = autoMatch[1].toUpperCase();
                    if (Object.prototype.hasOwnProperty.call(manualRates, code)) {
                        manualRates[code] = null;
                        applied = true;
                    }
                    continue;
                }
                const eqMatch = part.match(/^([A-Za-z]{3})\s*=\s*([0-9]*\.?[0-9]+)$/);
                if (eqMatch) {
                    const code = eqMatch[1].toUpperCase();
                    const val = Number(eqMatch[2]);
                    if (val > 0 && Object.prototype.hasOwnProperty.call(manualRates, code)) {
                        manualRates[code] = val;
                        applied = true;
                    }
                    continue;
                }
                const fallback = Number(part);
                if (!isNaN(fallback) && fallback > 0) {
                    manualRates.EUR = fallback;
                    applied = true;
                }
            }
            if (!applied) {
                alert('Please enter a valid override like "EUR=1.07" or "COP=0.00026" (use \'auto\' to clear).');
                return;
            }
            const summary = [
                manualRates.EUR ? `EUR→USD=${manualRates.EUR}` : 'EUR→USD auto',
                manualRates.COP ? `COP→USD=${manualRates.COP}` : 'COP→USD auto'
            ].join(' | ');
            alert('Manual override updated: ' + summary);
            convertCurrenciesToUSD().then(() => refreshVisualsAfterConversion());
        });

        // fetch live rates (best-effort)
        async function fetchLiveRates() {
            try {
                const [eurRes, copRes] = await Promise.all([
                    fetch('https://api.exchangerate.host/latest?base=EUR&symbols=USD'),
                    fetch('https://api.exchangerate.host/latest?base=COP&symbols=USD')
                ]);
                if (eurRes && eurRes.ok) {
                    const j = await eurRes.json();
                    if (j && j.rates && j.rates.USD) liveRates.EUR = Number(j.rates.USD);
                }
                if (copRes && copRes.ok) {
                    const j2 = await copRes.json();
                    if (j2 && j2.rates && j2.rates.USD) liveRates.COP = Number(j2.rates.USD);
                }
            } catch (e) {
                console.warn('rate fetch failed', e);
            }
        }
        fetchLiveRates();

        function showView(id) {
            Object.values(viewElements).forEach(view => view && view.classList.remove('active'));
            const targetView = viewElements[id];
            if (targetView) targetView.classList.add('active');
            Object.values(navButtons).forEach(btn => btn && btn.classList.remove('is-active'));
            if (navButtons[id]) navButtons[id].classList.add('is-active');
            if (bottomOverviewEl) {
                bottomOverviewEl.classList.toggle('hidden', id !== 'landingView');
            }
            if (id === 'workIncomeView') {
                populateWorkIncomeSelect();
                renderWorkIncomeChart();
            }
            if (normalized && normalized.length) {
                if (id === 'tsView') renderTimeSeriesByProvider();
                if (id === 'cumView') renderCumulativeByProvider();
                if (id === 'topView') renderTopWorksFull();
                if (id === 'revView') {
                    populateRevQuarter();
                    renderRevenueStack();
                }
            }
        }

        function isViewActive(viewId) {
            const view = viewElements[viewId];
            return !!(view && view.classList.contains('active'));
        }

        // CSV parsing helpers
        function parseCsvFile(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false,
                    transformHeader: h => h.trim(),
                    complete: results => {
                        if (results && results.data) resolve(results.data);
                        else reject(new Error('No data'));
                    },
                    error: err => reject(err)
                });
            });
        }

        function parseAmountSmart(v) {
            if (v === null || v === undefined) return NaN;
            if (typeof v === 'number') return v;
            let s = String(v).trim();
            if (s === '') return NaN;
            s = s.replace(/[^\d\.\,\-\u2212]/g, '');
            if (s === '') return NaN;
            const lastDot = s.lastIndexOf('.');
            const lastComma = s.lastIndexOf(',');
            if (lastDot !== -1 && lastComma !== -1) {
                if (lastComma > lastDot) {
                    s = s.replace(/\./g, '').replace(/,/g, '.');
                } else {
                    s = s.replace(/,/g, '');
                }
                const n = Number(s);
                return Number.isFinite(n) ? n : NaN;
            }
            if (lastComma !== -1 && lastDot === -1) {
                const after = s.length - lastComma - 1;
                if (after === 2 || after === 1) {
                    s = s.replace(/,/g, '.');
                    const n = Number(s);
                    return Number.isFinite(n) ? n : NaN;
                }
                s = s.replace(/,/g, '');
                const n = Number(s);
                return Number.isFinite(n) ? n : NaN;
            }
            if (lastDot !== -1 && lastComma === -1) {
                s = s.replace(/,/g, '');
                const n = Number(s);
                return Number.isFinite(n) ? n : NaN;
            }
            const n = Number(s.replace(/,/g, ''));
            return Number.isFinite(n) ? n : NaN;
        }

        function detectProvider(headers) {
            const normalized = headers.map(h => h.trim().toLowerCase());
            const compact = headers.map(h => h.replace(/\s+/g, '').trim().toLowerCase());
            const sgaeGross = SGAE_HEADERS.GROSS.toLowerCase();
            const sgaePeriod = SGAE_HEADERS.PERIOD.toLowerCase();
            const hasSgaeSignature = normalized.includes(sgaeGross) && normalized.includes(sgaePeriod);
            let fileTypeIdx = normalized.indexOf('file type');
            if (fileTypeIdx === -1) fileTypeIdx = compact.indexOf('filetype');
            const fileTypeHeader = fileTypeIdx !== -1 ? headers[fileTypeIdx] : null;
            if (hasSgaeSignature) {
                return {
                    provider: 'SGAE',
                    fileTypeHeader
                };
            }
            const hasWarnerSignature = normalized.includes('royalty_period') ||
                normalized.includes('tango_work_code') ||
                normalized.includes('tango_work_title') ||
                compact.includes('royaltyperiod') ||
                compact.includes('tangoworkcode') ||
                compact.includes('tangoworktitle');
            if (hasWarnerSignature) {
                return {
                    provider: 'WARNER CHAPPELL',
                    fileTypeHeader
                };
            }
            if (fileTypeHeader) {
                return {
                    provider: 'ASCAP (Int)',
                    fileTypeHeader
                };
            }
            const ascapMarkers = ['ascap', 'royalty', 'distribution', 'licensee', 'territory', 'ipi', 'member', 'work title', 'writer', 'us$', 'usd', 'net amount', 'gross amount'];
            let markerHits = 0;
            for (const h of normalized) {
                if (ascapMarkers.some(m => h.includes(m))) {
                    markerHits += 1;
                }
            }
            const looksAscDom = markerHits >= 2;
            return {
                provider: looksAscDom ? 'ASCAP (Dom)' : 'Other',
                fileTypeHeader
            };
        }

        function rowHasFileType(row, fileTypeHeader) {
            if (!fileTypeHeader) return false;
            if (row.hasOwnProperty(fileTypeHeader)) return true;
            const normalized = fileTypeHeader.replace(/\s+/g, '').trim().toLowerCase();
            return Object.keys(row).some(key => key && key.replace(/\s+/g, '').trim().toLowerCase() === normalized);
        }

        function rowLooksWarner(row) {
            if (!row) return false;
            const keys = Object.keys(row);
            for (const key of keys) {
                if (!key) continue;
                const normalized = key.replace(/[\s_]+/g, '').trim().toLowerCase();
                if (normalized === 'royaltyperiod' || normalized === 'tangoworkcode' || normalized === 'tangoworktitle') return true;
            }
            return false;
        }

        function extractHeadersFromRows(rows) {
            if (!Array.isArray(rows) || rows.length === 0) return [];
            const collected = new Set();
            for (const row of rows) {
                if (!row || typeof row !== 'object') continue;
                Object.keys(row).forEach(key => {
                    if (!key || key.startsWith('__')) return;
                    if (!collected.has(key)) collected.add(key);
                });
                if (collected.size) break;
            }
            return Array.from(collected);
        }

        function resolveProviderLabel(providerGuess, row, amountCol, fileTypeHeader) {
            const normalizedGuess = (providerGuess || '').toString().trim();
            const hasFileTypeColumn = rowHasFileType(row, fileTypeHeader);
            const looksWarner = rowLooksWarner(row);
            if (normalizedGuess === 'SGAE' || normalizedGuess === 'ASCAP (Dom)' || normalizedGuess === 'ASCAP (Int)' || normalizedGuess === 'WARNER CHAPPELL') return normalizedGuess;
            if (normalizedGuess === 'ASCAP') {
                return hasFileTypeColumn ? 'ASCAP (Int)' : 'ASCAP (Dom)';
            }
            if (looksWarner) return 'WARNER CHAPPELL';
            if (hasFileTypeColumn) return 'ASCAP (Int)';
            const amountSample = amountCol ? String(row[amountCol] || '').toLowerCase() : '';
            if (normalizedGuess === 'Other') {
                if (looksWarner) return 'WARNER CHAPPELL';
                if (amountSample.includes('€') || amountSample.includes('eur')) return 'SGAE';
                return hasFileTypeColumn ? 'ASCAP (Int)' : 'ASCAP (Dom)';
            }
            if (!normalizedGuess || normalizedGuess === 'Unknown') {
                if (looksWarner) return 'WARNER CHAPPELL';
                if (amountSample.includes('€') || amountSample.includes('eur')) return 'SGAE';
                return hasFileTypeColumn ? 'ASCAP (Int)' : 'ASCAP (Dom)';
            }
            return normalizedGuess;
        }

        function canonicalizeProvider(provider, rawCurrency) {
            const normalized = (provider || '').toString().trim();
            if (normalized === 'SGAE') return 'SGAE';
            if (normalized === 'ASCAP (Int)') return 'ASCAP (Int)';
            if (normalized === 'ASCAP (Dom)') return 'ASCAP (Dom)';
            if (normalized === 'WARNER CHAPPELL') return 'WARNER CHAPPELL';
            if (normalized === 'ASCAP') return 'ASCAP (Dom)';
            if (normalized === 'Unknown') {
                if (rawCurrency === 'EUR') return 'SGAE';
                if (rawCurrency === 'COP') return 'WARNER CHAPPELL';
                return 'ASCAP (Int)';
            }
            if (normalized === 'Other') {
                if (rawCurrency === 'EUR') return 'SGAE';
                if (rawCurrency === 'COP') return 'WARNER CHAPPELL';
                return 'ASCAP (Dom)';
            }
            if (rawCurrency === 'EUR') return 'SGAE';
            if (rawCurrency === 'COP') return 'WARNER CHAPPELL';
            return 'ASCAP (Dom)';
        }

        async function handleCsvFiles(e) {
            const files = Array.from(e.target.files || []);
            if (files.length === 0) return;
            rawDataRows = [];
            fileDiagnostics = [];
            showDiagnostics();
            markAllCachesDirty();
            for (const f of files) {
                try {
                    const rows = await parseCsvFile(f);
                    if (!rows || rows.length === 0) continue;
                    const headers = extractHeadersFromRows(rows);
                    if (!headers.length) {
                        console.warn('No headers detected for', f.name);
                        continue;
                    }
                    const detection = detectProvider(headers);
                    const provider = detection.provider;
                    const fileTypeHeader = detection.fileTypeHeader;
                    const headerLookup = new Map();
                    const compactLookup = new Map();
                    headers.forEach(h => {
                        const normalized = h.trim().toLowerCase();
                        const compactKey = h.replace(/[\s_]+/g, '').trim().toLowerCase();
                        headerLookup.set(normalized, h);
                        compactLookup.set(compactKey, h);
                    });
                    rows.forEach(r => r.__source_file = f.name);
                    const pickHeader = (...candidates) => {
                        for (const cand of candidates) {
                            if (!cand) continue;
                            const normalized = cand.trim().toLowerCase();
                            if (headerLookup.has(normalized)) return headerLookup.get(normalized);
                            const compactKey = cand.replace(/[\s_]+/g, '').trim().toLowerCase();
                            if (compactLookup.has(compactKey)) return compactLookup.get(compactKey);
                        }
                        return null;
                    };
                    let amountCol = null,
                        dedCol = null,
                        titleCol = null,
                        periodCol = null,
                        territoryCol = null,
                        periodYearCol = null,
                        periodQuarterCol = null;
                    let dedIsAlwaysZero = false;
                    if (provider === 'SGAE') {
                        if (headers.includes(SGAE_HEADERS.GROSS)) amountCol = SGAE_HEADERS.GROSS;
                        if (headers.includes(SGAE_HEADERS.DEDUCTION)) dedCol = SGAE_HEADERS.DEDUCTION;
                        if (headers.includes(SGAE_HEADERS.WORK_TITLE)) titleCol = SGAE_HEADERS.WORK_TITLE;
                        if (headers.includes(SGAE_HEADERS.PERIOD)) periodCol = SGAE_HEADERS.PERIOD;
                    } else if (provider === 'WARNER CHAPPELL') {
                        amountCol = pickHeader('amount_paid_less_tax', 'amount_paid') || headers[0];
                        titleCol = pickHeader('tango_work_title', 'tango_work_code');
                        periodCol = pickHeader('royalty_period');
                        territoryCol = pickHeader('source_territory_name', 'processing_territory_name');
                        dedCol = null;
                        dedIsAlwaysZero = true;
                    } else if (provider === 'ASCAP (Dom)') {
                        amountCol = pickHeader(
                            'Dollars',
                            'Dollar Amount',
                            'Net Amount',
                            'Net Amount USD',
                            'Net Royalty',
                            'Net USD',
                            'Amount Paid',
                            'Gross Amount'
                        );
                        if (!amountCol) {
                            amountCol = headers.find(h => /dollar|amount|importe|monto|total/i.test(h)) || headers[0];
                        }
                        titleCol = pickHeader(
                            'Work Title',
                            'work_title',
                            'WorkTitle',
                            'Title',
                            'Song Title',
                            'Titulo',
                            'Título'
                        );
                        if (!titleCol) titleCol = headers.find(h => /title|obra|work|tit/i.test(h));
                        periodYearCol = pickHeader('Distribution Year', 'DistributionYear', 'Royalty Year', 'Year');
                        periodQuarterCol = pickHeader('Distribution Quarter', 'DistributionQuarter', 'Royalty Quarter', 'Quarter');
                        periodCol = headers.find(h => /period|peri|date|fecha/i.test(h));
                        if (!periodCol) periodCol = periodQuarterCol || periodYearCol;
                        dedCol = headers.find(h => /dto|administr|admin|deduc/i.test(h));
                    } else {
                        amountCol = headers.find(h => /amount|dollar|importe|monto|total/i.test(h)) || headers[0];
                        titleCol = headers.find(h => /title|obra|work|tit/i.test(h));
                        periodCol = headers.find(h => /period|peri|date|fecha/i.test(h));
                        dedCol = headers.find(h => /dto|administr|admin|deduc/i.test(h));
                    }
                    rows.forEach(r => {
                        const gross = amountCol ? parseAmountSmart(r[amountCol]) : NaN;
                        const ded = dedIsAlwaysZero ? 0 : (dedCol ? parseAmountSmart(r[dedCol]) : 0);
                        const net = Number.isFinite(gross) ? (Number.isFinite(ded) ? gross - ded : gross) : NaN;
                        r.__parsed_amount_original = Number.isFinite(net) ? net : NaN;
                        const resolvedProvider = resolveProviderLabel(provider, r, amountCol, fileTypeHeader);
                        r.__detected_provider = resolvedProvider;
                        r.__currency = resolvedProvider === 'SGAE' ? 'EUR' : (resolvedProvider === 'WARNER CHAPPELL' ? 'COP' : 'USD');
                        r.__mapping = {
                            amountCol,
                            dedCol: dedIsAlwaysZero ? null : dedCol,
                            titleCol,
                            periodCol,
                            provider: r.__detected_provider,
                            territoryCol: territoryCol || null,
                            periodYearCol: periodYearCol || null,
                            periodQuarterCol: periodQuarterCol || null
                        };
                        if (titleCol) r.__work_title_candidate = r[titleCol];
                        if (periodCol) {
                            r.__period_raw = r[periodCol];
                            if (provider === 'WARNER CHAPPELL') {
                                const parsedWarner = parseWarnerPeriod(r[periodCol]);
                                if (parsedWarner) {
                                    r.__period_date_override = parsedWarner.date;
                                    r.__quarter_override = parsedWarner.quarter;
                                }
                            }
                        }
                        if (provider === 'ASCAP (Dom)') {
                            const parsedAscDom = parseAscDomesticPeriod(
                                periodYearCol ? r[periodYearCol] : undefined,
                                periodQuarterCol ? r[periodQuarterCol] : undefined,
                                periodCol ? r[periodCol] : undefined
                            );
                            if (parsedAscDom) {
                                r.__period_date_override = parsedAscDom.date;
                                r.__quarter_override = parsedAscDom.quarter;
                            }
                        }
                        if (territoryCol) r.__territory_candidate = r[territoryCol];
                    });
                    rawDataRows.push(...rows);
                    const total = rows.reduce((s, rr) => s + (Number.isFinite(rr.__parsed_amount_original) ? rr.__parsed_amount_original : 0), 0);
                    fileDiagnostics.push({
                        file: f.name,
                        provider,
                        providerOverride: 'auto',
                        fileTypeHeader,
                        headers,
                        dedIsAlwaysZero,
                        mapping: {
                            amountCol,
                            dedCol: dedIsAlwaysZero ? null : dedCol,
                            titleCol,
                            periodCol,
                            territoryCol,
                            periodYearCol: periodYearCol || null,
                            periodQuarterCol: periodQuarterCol || null,
                            provider
                        },
                        rows: rows.length,
                        fileTotal: total,
                        fileTotalSource: total,
                        fileTotalConverted: 0
                    });
                    showDiagnostics();
                } catch (err) {
                    console.error(err);
                    alert('Error parsing ' + f.name + ': ' + (err.message || err));
                }
            }
            normalized = normalizeDataFromCsv(rawDataRows);
            markAllCachesDirty();
            await convertCurrenciesToUSD();
            renderLandingKpis();
            populateWorkIncomeSelect();
            showView('landingView');
        }

        // periodo parser and normalization
        function parseQuarterParts(label) {
            if (!label) return null;
            const match = String(label).trim().match(/^(\d{4})-Q([1-4])$/i);
            if (!match) return null;
            const year = Number(match[1]);
            const quarter = Number(match[2]);
            if (!Number.isFinite(year) || !Number.isFinite(quarter)) return null;
            return { year, quarter };
        }

        function quarterLabelToDate(label) {
            if (!label) return null;
            const parts = parseQuarterParts(label);
            if (!parts) return null;
            const { year, quarter } = parts;
            return new Date(year, (quarter - 1) * 3, 1);
        }

        function parsePeriodoOrigen(v) {
            if (v === null || v === undefined) return null;
            const s = String(v).trim();
            if (!/^\d{6}$/.test(s)) return null;
            const year = Number(s.slice(0, 4));
            const q = Number(s.slice(4, 6));
            if (!(q >= 1 && q <= 4)) return null;
            return new Date(year, (q - 1) * 3, 1);
        }

        function parseWarnerPeriod(raw) {
            if (raw === null || raw === undefined) return null;
            const s = String(raw).trim();
            if (s === '') return null;
            const lower = s.toLowerCase();
            const digitsOnly = s.replace(/\D/g, '');
            const createResult = (year, quarter) => {
                if (!Number.isFinite(year) || !Number.isFinite(quarter)) return null;
                if (quarter < 1 || quarter > 4) return null;
                const monthIndex = (quarter - 1) * 3;
                const date = new Date(year, monthIndex, 1);
                if (isNaN(date)) return null;
                return {
                    date,
                    quarter: `${year}-Q${quarter}`
                };
            };
            const rangeMatch = digitsOnly.match(/^((?:19|20)\d{2})(0[1-9]|1[0-2])((?:19|20)\d{2})(0[1-9]|1[0-2])$/);
            if (rangeMatch) {
                const startYear = Number(rangeMatch[1]);
                const startMonth = Number(rangeMatch[2]);
                const endYear = Number(rangeMatch[3]);
                const endMonth = Number(rangeMatch[4]);
                let targetYear = Number.isFinite(endYear) ? endYear : null;
                let targetMonth = Number.isFinite(endMonth) && endMonth >= 1 && endMonth <= 12 ? endMonth : null;
                if (!(targetYear && targetMonth) && Number.isFinite(startYear) && Number.isFinite(startMonth) && startMonth >= 1 && startMonth <= 12) {
                    targetYear = startYear;
                    targetMonth = startMonth;
                }
                if (targetYear && targetMonth) {
                    const quarter = Math.ceil(targetMonth / 3);
                    const result = createResult(targetYear, quarter);
                    if (result) return result;
                }
            }
            const explicitAfterYear = lower.match(/((?:19|20)\d{2})\s*[-_/]?\s*q(?:tr)?\s*([1-4])/);
            if (explicitAfterYear) {
                const year = Number(explicitAfterYear[1]);
                const quarter = Number(explicitAfterYear[2]);
                const result = createResult(year, quarter);
                if (result) return result;
            }
            const explicitBeforeYear = lower.match(/q(?:tr)?\s*([1-4])\s*(?:-|\/|\s)*((?:19|20)\d{2})/);
            if (explicitBeforeYear) {
                const quarter = Number(explicitBeforeYear[1]);
                const year = Number(explicitBeforeYear[2]);
                const result = createResult(year, quarter);
                if (result) return result;
            }
            const compactQuarter = lower.match(/((?:19|20)\d{2})q([1-4])/);
            if (compactQuarter) {
                const year = Number(compactQuarter[1]);
                const quarter = Number(compactQuarter[2]);
                const result = createResult(year, quarter);
                if (result) return result;
            }
            const monthNames = {
                jan: 1,
                january: 1,
                feb: 2,
                february: 2,
                mar: 3,
                march: 3,
                apr: 4,
                april: 4,
                may: 5,
                jun: 6,
                june: 6,
                jul: 7,
                july: 7,
                aug: 8,
                august: 8,
                sep: 9,
                sept: 9,
                september: 9,
                oct: 10,
                october: 10,
                nov: 11,
                november: 11,
                dec: 12,
                december: 12
            };
            const yearMatch = lower.match(/(19|20)\d{2}/);
            const monthNameMatch = lower.match(/(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t|tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)/);
            if (yearMatch && monthNameMatch) {
                const year = Number(yearMatch[0]);
                const rawMonthKey = monthNameMatch[1];
                const monthKey = Object.keys(monthNames).find(key => rawMonthKey.startsWith(key));
                const month = monthNames[monthKey];
                if (Number.isFinite(month)) {
                    const quarter = Math.floor((month - 1) / 3) + 1;
                    const result = createResult(year, quarter);
                    if (result) return result;
                }
            }
            const monthAfterYear = lower.match(/((?:19|20)\d{2})[^0-9a-z]*(0?[1-9]|1[0-2])/);
            if (monthAfterYear) {
                const year = Number(monthAfterYear[1]);
                const month = Number(monthAfterYear[2]);
                if (Number.isFinite(month) && month >= 1 && month <= 12) {
                    const quarter = Math.floor((month - 1) / 3) + 1;
                    const result = createResult(year, quarter);
                    if (result) return result;
                }
            }
            const monthBeforeYear = lower.match(/(?:^|[^0-9a-z])(0?[1-9]|1[0-2])[^0-9a-z]*((?:19|20)\d{2})/);
            if (monthBeforeYear) {
                const month = Number(monthBeforeYear[1]);
                const year = Number(monthBeforeYear[2]);
                if (Number.isFinite(month) && month >= 1 && month <= 12) {
                    const quarter = Math.floor((month - 1) / 3) + 1;
                    const result = createResult(year, quarter);
                    if (result) return result;
                }
            }
            const compactMonth = lower.match(/((?:19|20)\d{2})(0[1-9]|1[0-2])/);
            if (compactMonth) {
                const year = Number(compactMonth[1]);
                const month = Number(compactMonth[2]);
                const quarter = Math.floor((month - 1) / 3) + 1;
                const result = createResult(year, quarter);
                if (result) return result;
            }
            return null;
        }

        function parseAscDomesticPeriod(rawYear, rawQuarter, fallbackRaw) {
            const extractYear = (...values) => {
                for (const value of values) {
                    if (value === null || value === undefined) continue;
                    const s = String(value).trim();
                    if (s === '') continue;
                    const match = s.match(/(19|20)\d{2}/);
                    if (match) {
                        const year = Number(match[0]);
                        if (Number.isFinite(year)) return year;
                    }
                }
                return null;
            };
            const extractQuarter = (...values) => {
                for (const value of values) {
                    if (value === null || value === undefined) continue;
                    const s = String(value).trim();
                    if (s === '') continue;
                    const match = s.match(/Q?\s*([1-4])/i);
                    if (match) {
                        const q = Number(match[1]);
                        if (Number.isFinite(q) && q >= 1 && q <= 4) return q;
                    }
                    const lowered = s.toLowerCase();
                    if (/(first|1st)/.test(lowered)) return 1;
                    if (/(second|2nd)/.test(lowered)) return 2;
                    if (/(third|3rd)/.test(lowered)) return 3;
                    if (/(fourth|4th)/.test(lowered)) return 4;
                }
                return null;
            };
            const year = extractYear(rawYear, fallbackRaw, rawQuarter);
            const quarter = extractQuarter(rawQuarter, fallbackRaw);
            if (!year || !quarter) return null;
            const date = new Date(year, (quarter - 1) * 3, 1);
            if (isNaN(date)) return null;
            return {
                date,
                quarter: `${year}-Q${quarter}`
            };
        }

        function normalizeDataFromCsv(rows) {
            return rows.map((r, idx) => {
                const out = {
                    _rawIndex: idx
                };
                out.work_title = r.__work_title_candidate || r['TIT. OBRA MUSICAL'] || r['TITLE'] || 'Unknown';
                const rawCurrency = (r.__currency || 'USD').toString().trim().toUpperCase();
                out.raw_currency = rawCurrency;
                out.source_amount = Number.isFinite(r.__parsed_amount_original) ? r.__parsed_amount_original : 0;
                const detectedProvider = (r.__mapping && r.__mapping.provider) ? r.__mapping.provider : (r.__detected_provider || '');
                out.provider = canonicalizeProvider(detectedProvider, out.raw_currency);
                let dt = null;
                if (r.__period_date_override instanceof Date && !isNaN(r.__period_date_override)) dt = r.__period_date_override;
                if (!dt && r.__period_raw) dt = parsePeriodoOrigen(r.__period_raw);
                if (!dt && r.__period_raw) dt = tryParseDate(r.__period_raw);
                let quarterLabel = r.__quarter_override || null;
                if (dt) {
                    out.distribution_date = dt;
                    if (!quarterLabel) {
                        const q = Math.floor(dt.getMonth() / 3) + 1;
                        quarterLabel = `${dt.getFullYear()}-Q${q}`;
                    }
                    const qm = quarterLabel && quarterLabel.match(/^(\d{4})-Q([1-4])$/);
                    if (qm) {
                        const qYear = Number(qm[1]);
                        const qNum = Number(qm[2]);
                        out.quarterDate = new Date(qYear, (qNum - 1) * 3, 1);
                    } else {
                        out.quarterDate = new Date(dt.getFullYear(), Math.floor(dt.getMonth() / 3) * 3, 1);
                    }
                } else if (quarterLabel) {
                    const qm = quarterLabel.match(/^(\d{4})-Q([1-4])$/);
                    if (qm) {
                        const qYear = Number(qm[1]);
                        const qNum = Number(qm[2]);
                        out.quarterDate = new Date(qYear, (qNum - 1) * 3, 1);
                        out.distribution_date = out.quarterDate;
                    } else {
                        out.quarterDate = null;
                        out.distribution_date = null;
                    }
                } else {
                    out.distribution_date = null;
                    out.quarterDate = null;
                }
                out.quarter = quarterLabel || (out.quarterDate ? `${out.quarterDate.getFullYear()}-Q${Math.floor(out.quarterDate.getMonth() / 3) + 1}` : 'Unknown');
                out.revenue_class_description = pickRevenueClassValue(r);
                out.country_name = r.__territory_candidate || r['source_territory_name'] || r['processing_territory_name'] || r['PAIS'] || r['PROCEDENCIA'] || r['country'] || '';
                out.__source_file = r.__source_file;
                return out;
            });
        }

        function tryParseDate(v) {
            if (!v) return null;
            const s = String(v).trim();
            if (s === '') return null;
            const d = new Date(s);
            if (!isNaN(d)) return d;
            const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
            if (m) {
                const dd = Number(m[1]),
                    mm = Number(m[2]) - 1,
                    yy = Number(m[3]);
                const d2 = new Date(yy, mm, dd);
                if (!isNaN(d2)) return d2;
            }
            return null;
        }

        // currency conversion
        async function convertCurrenciesToUSD() {
            if (liveRates.EUR === null || liveRates.COP === null) await fetchLiveRates();
            const eurRate = manualRates.EUR ?? liveRates.EUR ?? FALLBACK_RATES.EUR;
            const copRate = manualRates.COP ?? liveRates.COP ?? FALLBACK_RATES.COP;
            normalized.forEach(r => {
                const currency = (r.raw_currency || 'USD').toUpperCase();
                const baseAmount = r.source_amount || 0;
                if (currency === 'EUR') {
                    r.amount = baseAmount * eurRate;
                    r._display_currency = 'USD';
                } else if (currency === 'COP') {
                    r.amount = baseAmount * copRate;
                    r._display_currency = 'USD';
                } else {
                    r.amount = baseAmount;
                    r._display_currency = currency;
                }
            });
            markAllCachesDirty();
            updateDiagnosticsTotals();
        }

        // provider aggregation helpers (cached)
        function aggregateByQuarterByProvider() {
            if (!providerAggregationDirty && providerAggregationCache) return providerAggregationCache;
            const data = normalized || [];
            const quartersSet = new Set();
            const provMap = new Map();
            const totals = new Map();
            const quarterDateMap = new Map();
            for (const r of data) {
                const q = r.quarter || 'Unknown';
                quartersSet.add(q);
                const prov = r.provider || 'Unknown';
                if (!provMap.has(prov)) provMap.set(prov, new Map());
                const qm = provMap.get(prov);
                qm.set(q, (qm.get(q) || 0) + (Number.isFinite(r.amount) ? r.amount : 0));
                totals.set(prov, (totals.get(prov) || 0) + (Number.isFinite(r.amount) ? r.amount : 0));
                if (r.quarter && r.quarterDate instanceof Date && !isNaN(r.quarterDate)) {
                    if (!quarterDateMap.has(r.quarter)) quarterDateMap.set(r.quarter, r.quarterDate);
                }
            }
            const toSortValue = (label) => {
                const stored = quarterDateMap.get(label);
                if (stored instanceof Date && !isNaN(stored)) return stored.getTime();
                const parts = parseQuarterParts(label);
                if (parts) {
                    return new Date(parts.year, (parts.quarter - 1) * 3, 1).getTime();
                }
                return Number.MAX_SAFE_INTEGER;
            };
            const quarters = Array.from(quartersSet).sort((a, b) => toSortValue(a) - toSortValue(b));
            const quarterDates = quarters.map(label => {
                const stored = quarterDateMap.get(label);
                if (stored instanceof Date && !isNaN(stored)) return stored;
                const parts = parseQuarterParts(label);
                if (parts) return new Date(parts.year, (parts.quarter - 1) * 3, 1);
                return null;
            });
            const providers = Array.from(provMap.keys()).sort((a, b) => (totals.get(b) || 0) - (totals.get(a) || 0));
            const series = providers.map(prov => {
                const qm = provMap.get(prov);
                const values = quarters.map(q => (qm && qm.get(q)) ? qm.get(q) : 0);
                return {
                    provider: prov,
                    values,
                    total: totals.get(prov) || 0
                };
            });
            providerAggregationCache = {
                quarters,
                quarterDates,
                series,
                providers
            };
            providerAggregationDirty = false;
            return providerAggregationCache;
        }

        // render time series by provider with mode
        function renderTimeSeriesByProvider() {
            if (!timeSeriesEl) return;
            const agg = aggregateByQuarterByProvider();
            if (!agg.quarters || agg.quarters.length === 0) {
                timeSeriesEl.innerHTML = '<div class="small">No data</div>';
                return;
            }
            const chartType = tsChartTypeEl ? tsChartTypeEl.value : 'stacked';
            const hideOther = !!(tsHideOtherEl && tsHideOtherEl.checked);
            const quartersDates = (Array.isArray(agg.quarterDates) && agg.quarterDates.length === agg.quarters.length)
                ? agg.quarterDates
                : agg.quarters.map(q => {
                    const any = normalized.find(r => r.quarter === q && r.quarterDate instanceof Date && !isNaN(r.quarterDate));
                    if (any) return any.quarterDate;
                    const parts = parseQuarterParts(q);
                    return parts ? new Date(parts.year, (parts.quarter - 1) * 3, 1) : null;
                });
            const palette = ['#4A90E2', '#50E3C2', '#AAB4C2', '#E94E3D', '#7A8A9F'];
            const fillPalette = ['rgba(74,144,226,0.45)', 'rgba(80,227,194,0.45)', 'rgba(170,180,194,0.45)', 'rgba(233,78,61,0.45)', 'rgba(122,138,159,0.45)'];
            const traces = [];
            for (const s of agg.series) {
                if (hideOther && s.provider === 'Other') continue;
                if (chartType === 'stacked') {
                    traces.push({
                        x: quartersDates,
                        y: s.values,
                        name: s.provider,
                        type: 'scatter',
                        mode: 'none',
                        stackgroup: 'stack',
                        hoverinfo: 'x+y+name',
                        line: { width: 0 },
                        fillcolor: fillPalette[traces.length % fillPalette.length]
                    });
                } else {
                    traces.push({
                        x: quartersDates,
                        y: s.values,
                        name: s.provider,
                        type: 'scatter',
                        mode: 'lines+markers',
                        hoverinfo: 'x+y+name',
                        line: {
                            width: 3,
                            color: palette[traces.length % palette.length]
                        },
                        marker: {
                            size: 6,
                            color: palette[traces.length % palette.length]
                        }
                    });
                }
            }
            const layout = {
                template: 'plotly_dark',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    family: 'Inter, sans-serif',
                    color: '#E0E6ED'
                },
                title: {
                    text: 'Net income over time by provider (USD)',
                    font: {
                        size: 22,
                        color: '#4A90E2'
                    }
                },
                margin: {
                    t: 60,
                    b: 50,
                    l: 60,
                    r: 30
                },
                xaxis: {
                    tickformat: '%Y-Q%q',
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: '',
                        font: { color: '#AAB4C2' }
                    }
                },
                yaxis: {
                    tickformat: '.2f',
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: '',
                        font: { color: '#AAB4C2' }
                    }
                },
                showlegend: traces.length > 1
            };
            Plotly.newPlot(timeSeriesEl, traces, layout, {
                responsive: true,
                displayModeBar: true
            });
        }

        // render cumulative per provider with mode
        function renderCumulativeByProvider() {
            if (!cumulativeEl) return;
            const agg = aggregateByQuarterByProvider();
            if (!agg.quarters || agg.quarters.length === 0) {
                cumulativeEl.innerHTML = '<div class="small">No data</div>';
                return;
            }
            const chartType = cumChartTypeEl ? cumChartTypeEl.value : 'stacked';
            const hideOther = !!(cumHideOtherEl && cumHideOtherEl.checked);
            const quartersDates = (Array.isArray(agg.quarterDates) && agg.quarterDates.length === agg.quarters.length)
                ? agg.quarterDates
                : agg.quarters.map(q => {
                    const any = normalized.find(r => r.quarter === q && r.quarterDate instanceof Date && !isNaN(r.quarterDate));
                    if (any) return any.quarterDate;
                    const parts = parseQuarterParts(q);
                    return parts ? new Date(parts.year, (parts.quarter - 1) * 3, 1) : null;
                });
            const palette = ['#4A90E2', '#50E3C2', '#AAB4C2', '#E94E3D', '#7A8A9F'];
            const fillPalette = ['rgba(74,144,226,0.45)', 'rgba(80,227,194,0.45)', 'rgba(170,180,194,0.45)', 'rgba(233,78,61,0.45)', 'rgba(122,138,159,0.45)'];
            const cumSeries = agg.series.map(s => {
                let cum = 0;
                const vals = s.values.map(v => {
                    cum += v;
                    return cum;
                });
                return {
                    provider: s.provider,
                    values: vals,
                    total: s.total
                };
            });
            const traces = [];
            for (const s of cumSeries) {
                if (hideOther && s.provider === 'Other') continue;
                if (chartType === 'stacked') {
                    traces.push({
                        x: quartersDates,
                        y: s.values,
                        name: s.provider,
                        type: 'scatter',
                        mode: 'none',
                        stackgroup: 'stack',
                        hoverinfo: 'x+y+name',
                        line: { width: 0 },
                        fillcolor: fillPalette[traces.length % fillPalette.length]
                    });
                } else {
                    traces.push({
                        x: quartersDates,
                        y: s.values,
                        name: s.provider,
                        type: 'scatter',
                        mode: 'lines+markers',
                        hoverinfo: 'x+y+name',
                        line: {
                            width: 3,
                            color: palette[traces.length % palette.length]
                        },
                        marker: {
                            size: 6,
                            color: palette[traces.length % palette.length]
                        }
                    });
                }
            }
            const layout = {
                template: 'plotly_dark',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    family: 'Inter, sans-serif',
                    color: '#E0E6ED'
                },
                title: {
                    text: 'Cumulative income by provider (USD)',
                    font: {
                        size: 22,
                        color: '#4A90E2'
                    }
                },
                margin: {
                    t: 60,
                    b: 50,
                    l: 60,
                    r: 30
                },
                xaxis: {
                    tickformat: '%Y-Q%q',
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: '',
                        font: { color: '#AAB4C2' }
                    }
                },
                yaxis: {
                    tickformat: '.2f',
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: '',
                        font: { color: '#AAB4C2' }
                    }
                },
                showlegend: traces.length > 1
            };
            Plotly.newPlot(cumulativeEl, traces, layout, {
                responsive: true,
                displayModeBar: true
            });
        }

        // remaining renderers and revenue stack
        function aggregateByQuarter(data) {
            const map = new Map();
            for (const r of data)
                if (r.quarterDate) {
                    const k = r.quarter;
                    if (!map.has(k)) map.set(k, {
                        quarterDate: r.quarterDate,
                        amount: 0
                    });
                    map.get(k).amount += r.amount || 0;
                } const items = Array.from(map.entries()).map(([k, v]) => ({
                quarter: k,
                quarterDate: v.quarterDate,
                amount: v.amount
            })).sort((a, b) => a.quarterDate - b.quarterDate);
            return items;
        }

        function aggregateCumulative(ts) {
            let cum = 0;
            return ts.map(i => {
                cum += i.amount;
                return {
                    quarter: i.quarter,
                    quarterDate: i.quarterDate,
                    cumulative: cum
                };
            });
        }

        function canonicalizeWorkTitle(title) {
            if (!title && title !== 0) return '';
            let normalizedTitle = String(title)
                .trim()
                .replace(/\s+/g, ' ');
            if (typeof normalizedTitle.normalize === 'function') {
                normalizedTitle = normalizedTitle
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '');
            }
            return normalizedTitle.toLowerCase();
        }

        function markProviderAggDirty() {
            providerAggregationDirty = true;
            providerAggregationCache = null;
        }

        function markRevenueTableDirty() {
            revenueTableDirty = true;
            revenueTableCache = null;
        }

        function markAllCachesDirty() {
            markWorkIncomeCacheDirty();
            markProviderAggDirty();
            markRevenueTableDirty();
        }

        function markWorkIncomeCacheDirty() {
            workIncomeCacheDirty = true;
        }

        function deriveQuarterInfoForRow(row) {
            if (!row) return null;
            const rawQuarter = row.quarter ? String(row.quarter).trim() : '';
            const directParts = parseQuarterParts(rawQuarter);
            if (directParts) {
                const label = `${directParts.year}-Q${directParts.quarter}`;
                const baseDate = (row.quarterDate instanceof Date && !isNaN(row.quarterDate))
                    ? new Date(row.quarterDate.getFullYear(), Math.floor(row.quarterDate.getMonth() / 3) * 3, 1)
                    : quarterLabelToDate(label);
                if (baseDate instanceof Date && !isNaN(baseDate)) {
                    return { label, date: baseDate };
                }
            }
            if (row.quarterDate instanceof Date && !isNaN(row.quarterDate)) {
                const qDate = row.quarterDate;
                const q = Math.floor(qDate.getMonth() / 3) + 1;
                const label = `${qDate.getFullYear()}-Q${q}`;
                return {
                    label,
                    date: new Date(qDate.getFullYear(), (q - 1) * 3, 1)
                };
            }
            return null;
        }

        function compareQuarterLabels(a, b) {
            const aParts = parseQuarterParts(a);
            const bParts = parseQuarterParts(b);
            if (!aParts && !bParts) return 0;
            if (!aParts) return 1;
            if (!bParts) return -1;
            if (aParts.year !== bParts.year) return aParts.year - bParts.year;
            return aParts.quarter - bParts.quarter;
        }

        function advanceQuarterParts(parts) {
            if (!parts) return;
            if (parts.quarter === 4) {
                parts.quarter = 1;
                parts.year += 1;
            } else {
                parts.quarter += 1;
            }
        }

        function isAfterQuarterParts(a, b) {
            if (!a || !b) return false;
            return a.year > b.year || (a.year === b.year && a.quarter > b.quarter);
        }

        function ensureWorkIncomeCache() {
            if (!workIncomeCacheDirty) return;
            workIncomeCache.clear();
            workIncomeCacheDirty = false;
            if (!normalized || !normalized.length) return;
            const buckets = new Map();
            normalized.forEach(row => {
                const title = row && row.work_title ? String(row.work_title).trim() : '';
                if (!title) return;
                const key = canonicalizeWorkTitle(title);
                if (!key) return;
                if (!buckets.has(key)) {
                    buckets.set(key, {
                        labels: new Map(),
                        quarters: new Map()
                    });
                }
                const bucket = buckets.get(key);
                bucket.labels.set(title, (bucket.labels.get(title) || 0) + 1);
                const quarterInfo = deriveQuarterInfoForRow(row);
                if (!quarterInfo) return;
                if (!bucket.quarters.has(quarterInfo.label)) {
                    bucket.quarters.set(quarterInfo.label, {
                        amount: 0,
                        quarterDate: quarterInfo.date
                    });
                }
                const quarterEntry = bucket.quarters.get(quarterInfo.label);
                quarterEntry.amount += row.amount || 0;
                if (!quarterEntry.quarterDate || !(quarterEntry.quarterDate instanceof Date) || isNaN(quarterEntry.quarterDate)) {
                    quarterEntry.quarterDate = quarterInfo.date;
                }
            });
            buckets.forEach((bucket, key) => {
                const labelCandidates = Array.from(bucket.labels.entries());
                let displayName = labelCandidates.length
                    ? labelCandidates.sort((a, b) => {
                        if (b[1] !== a[1]) return b[1] - a[1];
                        return a[0].localeCompare(b[0], undefined, { sensitivity: 'base' });
                    })[0][0]
                    : key;
                const quarterKeys = Array.from(bucket.quarters.keys()).sort(compareQuarterLabels);
                const series = [];
                if (quarterKeys.length) {
                    const firstParts = parseQuarterParts(quarterKeys[0]);
                    const lastParts = parseQuarterParts(quarterKeys[quarterKeys.length - 1]);
                    if (firstParts && lastParts) {
                        const cursor = { ...firstParts };
                        while (!isAfterQuarterParts(cursor, lastParts)) {
                            const label = `${cursor.year}-Q${cursor.quarter}`;
                            const entry = bucket.quarters.get(label);
                            const date = (entry && entry.quarterDate instanceof Date && !isNaN(entry.quarterDate))
                                ? entry.quarterDate
                                : quarterLabelToDate(label);
                            series.push({
                                quarter: label,
                                quarterDate: date instanceof Date && !isNaN(date) ? date : quarterLabelToDate(label),
                                amount: entry ? entry.amount : 0
                            });
                            advanceQuarterParts(cursor);
                        }
                    }
                }
                workIncomeCache.set(key, {
                    displayName,
                    series
                });
            });
        }

        function populateWorkIncomeSelect() {
            if (!workIncomeSelectEl) return;
            ensureWorkIncomeCache();
            const previous = currentWorkIncomeWork || workIncomeSelectEl.value || '';
            workIncomeSelectEl.innerHTML = '';
            const entries = Array.from(workIncomeCache.entries()).map(([key, value]) => ({
                key,
                displayName: value.displayName && value.displayName.trim().length ? value.displayName : key
            })).sort((a, b) => a.displayName.localeCompare(b.displayName, undefined, { sensitivity: 'base' }));
            if (!entries.length) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.text = 'No works available';
                workIncomeSelectEl.appendChild(opt);
                workIncomeSelectEl.disabled = true;
                currentWorkIncomeWork = null;
                if (downloadWorkIncomeBtn) downloadWorkIncomeBtn.disabled = true;
                return;
            }
            workIncomeSelectEl.disabled = false;
            entries.forEach(entry => {
                const opt = document.createElement('option');
                opt.value = entry.displayName;
                opt.text = entry.displayName;
                workIncomeSelectEl.appendChild(opt);
            });
            const previousKey = canonicalizeWorkTitle(previous);
            let nextSelection = '';
            if (previousKey && workIncomeCache.has(previousKey)) {
                nextSelection = workIncomeCache.get(previousKey).displayName;
            } else {
                nextSelection = entries[0].displayName;
            }
            currentWorkIncomeWork = nextSelection;
            workIncomeSelectEl.value = nextSelection;
        }

        function buildWorkIncomeSeries(workTitle) {
            ensureWorkIncomeCache();
            if (!workTitle || !normalized || !normalized.length) {
                return {
                    series: [],
                    displayName: workTitle || ''
                };
            }
            const targetKey = canonicalizeWorkTitle(workTitle);
            if (!targetKey) {
                return {
                    series: [],
                    displayName: workTitle || ''
                };
            }
            const cached = workIncomeCache.get(targetKey);
            if (!cached) {
                return {
                    series: [],
                    displayName: workTitle || ''
                };
            }
            return {
                series: cached.series,
                displayName: cached.displayName
            };
        }

        function renderWorkIncomeChart() {
            if (!workIncomeChartEl) return;
            if (!normalized || normalized.length === 0) {
                if (typeof Plotly !== 'undefined') Plotly.purge(workIncomeChartEl);
                workIncomeChartEl.innerHTML = '<div class="small">Upload statements to explore work income.</div>';
                if (downloadWorkIncomeBtn) downloadWorkIncomeBtn.disabled = true;
                return;
            }
            if (workIncomeSelectEl && workIncomeSelectEl.disabled) {
                workIncomeChartEl.innerHTML = '<div class="small">No works available.</div>';
                if (downloadWorkIncomeBtn) downloadWorkIncomeBtn.disabled = true;
                return;
            }
            const selectedWork = workIncomeSelectEl ? workIncomeSelectEl.value : currentWorkIncomeWork;
            if (!selectedWork) {
                if (typeof Plotly !== 'undefined') Plotly.purge(workIncomeChartEl);
                workIncomeChartEl.innerHTML = '<div class="small">Select a work to view its performance.</div>';
                if (downloadWorkIncomeBtn) downloadWorkIncomeBtn.disabled = true;
                return;
            }
            currentWorkIncomeWork = selectedWork;
            const { series, displayName } = buildWorkIncomeSeries(selectedWork);
            const resolvedName = displayName || selectedWork;
            currentWorkIncomeWork = resolvedName;
            if (workIncomeSelectEl && workIncomeSelectEl.value !== resolvedName) {
                workIncomeSelectEl.value = resolvedName;
            }
            const sanitizedSeries = (series || []).map(point => {
                const date = (point && point.quarterDate instanceof Date && !isNaN(point.quarterDate))
                    ? point.quarterDate
                    : quarterLabelToDate(point ? point.quarter : null);
                if (!(date instanceof Date) || isNaN(date)) return null;
                return {
                    quarter: point.quarter,
                    quarterDate: date,
                    amount: point.amount || 0
                };
            }).filter(Boolean);
            if (!sanitizedSeries.length) {
                if (typeof Plotly !== 'undefined') Plotly.purge(workIncomeChartEl);
                workIncomeChartEl.innerHTML = `<div class="small">No quarterly data found for <strong>${escapeHtml(resolvedName)}</strong>.</div>`;
                if (downloadWorkIncomeBtn) downloadWorkIncomeBtn.disabled = true;
                return;
            }
            const mode = workIncomeModeEl ? workIncomeModeEl.value : 'series';
            const x = sanitizedSeries.map(point => point.quarterDate);
            const baseY = sanitizedSeries.map(point => point.amount || 0);
            let y = baseY;
            if (mode === 'cumulative') {
                let sum = 0;
                y = baseY.map(val => {
                    sum += val;
                    return sum;
                });
            }
            const yLabel = mode === 'cumulative' ? 'Cumulative income (USD)' : 'Income (USD)';
            const titleDetail = mode === 'cumulative' ? 'Cumulative income' : 'Quarterly income';
            const trace = {
                x,
                y,
                customdata: sanitizedSeries.map(point => point.quarter),
                type: 'scatter',
                mode: 'lines+markers',
                line: {
                    color: '#7CF1B4',
                    width: 4
                },
                marker: {
                    size: 8,
                    color: '#7CF1B4',
                    line: {
                        width: 1,
                        color: '#0B1C24'
                    }
                },
                hovertemplate: '<b>%{customdata}</b><br>$%{y:,.2f}<extra></extra>'
            };
            const layout = {
                template: 'plotly_dark',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    family: 'Inter, sans-serif',
                    color: '#E0E6ED'
                },
                title: {
                    text: `${resolvedName} — ${titleDetail}`,
                    font: {
                        size: 22,
                        color: '#7CF1B4'
                    }
                },
                margin: {
                    t: 60,
                    b: 60,
                    l: 70,
                    r: 30
                },
                xaxis: {
                    type: 'date',
                    tickformat: '%Y-Q%q',
                    hoverformat: '%Y-Q%q',
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: 'Quarter',
                        font: { color: '#AAB4C2' }
                    }
                },
                yaxis: {
                    tickformat: '$,.2f',
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: yLabel,
                        font: { color: '#AAB4C2' }
                    }
                },
                transition: {
                    duration: 400,
                    easing: 'cubic-in-out'
                },
                showlegend: false
            };
            const config = {
                responsive: true,
                displayModeBar: true,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'work_income_over_time'
                }
            };
            workIncomeChartEl.innerHTML = '';
            if (typeof Plotly !== 'undefined') {
                Plotly.purge(workIncomeChartEl);
                Plotly.newPlot(workIncomeChartEl, [trace], layout, config);
            }
            if (downloadWorkIncomeBtn) downloadWorkIncomeBtn.disabled = false;
        }

        // IMPORTANT: limit top works to top 10
        function aggregateTopWorks(data, topN = 10) {
            const m = new Map();
            for (const r of data) {
                const w = r.work_title || 'Unknown';
                m.set(w, (m.get(w) || 0) + (r.amount || 0));
            }
            const arr = Array.from(m.entries()).map(([k, v]) => ({
                work_title: k,
                amount: v
            }));
            arr.sort((a, b) => b.amount - a.amount);
            return arr.slice(0, topN);
        }

        function renderTopWorksFull() {
            if (!topWorksEl) return;
            const top = aggregateTopWorks(normalized, 10);
            if (!top.length) {
                topWorksEl.innerHTML = '<div class="small">No data</div>';
                return;
            }
            const x = top.map(t => t.amount).reverse(),
                y = top.map(t => t.work_title).reverse();
            const trace = {
                x,
                y,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: '#4A90E2'
                }
            };
            const layout = {
                template: 'plotly_dark',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    family: 'Inter, sans-serif',
                    color: '#E0E6ED'
                },
                title: {
                    text: 'Top 10 works (USD)',
                    font: {
                        size: 22,
                        color: '#4A90E2'
                    }
                },
                margin: {
                    t: 60,
                    b: 50,
                    l: 260,
                    r: 30
                },
                xaxis: {
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: 'USD',
                        font: { color: '#AAB4C2' }
                    }
                },
                yaxis: {
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2'
                },
                showlegend: false
            };
            Plotly.newPlot(topWorksEl, [trace], layout, {
                responsive: true,
                displayModeBar: true
            });
        }

        // revenue stack logic (DESCRIP. CONCEP / Revenue Class Description / Music User Genre)
        function normalizeClassLabel(raw) {
            if (raw === null || raw === undefined) return 'Unspecified';
            let s = String(raw).trim();
            if (s === '') return 'Unspecified';
            s = s.replace(/\s+/g, ' ').replace(/\.$/, '').trim();
            return s;
        }

        function pickRevenueClassValue(record) {
            const fields = ['DESCRIP. CONCEP', 'Revenue Class Description', 'Music User Genre'];
            for (const key of fields) {
                const raw = record[key];
                if (raw === null || raw === undefined) continue;
                const s = String(raw).trim();
                if (s !== '') return s;
            }
            return '';
        }

        function buildRevenueTable() {
            if (!revenueTableDirty && revenueTableCache) return revenueTableCache;
            const data = normalized || [];
            const quarterMap = new Map();
            for (const r of data) {
                const q = r.quarter || 'Unknown';
                const cls = normalizeClassLabel(r.revenue_class_description || 'Unspecified');
                if (!quarterMap.has(q)) quarterMap.set(q, new Map());
                const cm = quarterMap.get(q);
                cm.set(cls, (cm.get(cls) || 0) + (r.amount || 0));
            }
            const totalByClass = new Map();
            for (const [q, cm] of quarterMap.entries()) {
                for (const [cls, val] of cm.entries()) totalByClass.set(cls, (totalByClass.get(cls) || 0) + val);
            }
            const quarterDates = {};
            for (const r of data) {
                if (r.quarter && r.quarterDate) quarterDates[r.quarter] = r.quarterDate;
            }
            const quarters = Array.from(quarterMap.keys()).sort((a, b) => (quarterDates[a] || 0) - (quarterDates[b] || 0));
            revenueTableCache = {
                quarterMap,
                quarters,
                totalByClass
            };
            revenueTableDirty = false;
            return revenueTableCache;
        }

        function chooseStackClasses(table, selectedQuarter, topN, thresholdPercent) {
            const totalByClassArr = Array.from(table.totalByClass.entries()).sort((a, b) => b[1] - a[1]);
            const topNclasses = totalByClassArr.slice(0, topN).map(x => x[0]);
            const perQuarter = table.quarterMap.get(selectedQuarter) || new Map();
            const quarterTotal = Array.from(perQuarter.values()).reduce((s, v) => s + v, 0);
            const thresholdAbs = (thresholdPercent / 100) * quarterTotal;
            const includeFromQuarter = [];
            for (const [cls, val] of perQuarter.entries()) {
                if (val >= thresholdAbs && !topNclasses.includes(cls)) includeFromQuarter.push(cls);
            }
            const selected = Array.from(new Set([...topNclasses, ...includeFromQuarter]));
            return selected;
        }

        function renderRevenueStack() {
            if (!revenueStackEl) return;
            const controls = getRevControls();
            const table = buildRevenueTable();
            if (!table.quarters || table.quarters.length === 0) {
                revenueStackEl.innerHTML = '<div class="small">No data</div>';
                return;
            }
            if (!revQuarterSelectEl) {
                revenueStackEl.innerHTML = '<div class="small">Quarter selector missing</div>';
                return;
            }
            if (!revQuarterSelectEl.options.length) {
                table.quarters.forEach(q => {
                    const opt = document.createElement('option');
                    opt.value = q;
                    opt.text = q;
                    revQuarterSelectEl.appendChild(opt);
                });
                revQuarterSelectEl.value = table.quarters[table.quarters.length - 1];
            }
            const selectedQuarter = revQuarterSelectEl.value || table.quarters[table.quarters.length - 1];
            const selectedClasses = chooseStackClasses(table, selectedQuarter, controls.topN, controls.threshold);
            const quarters = table.quarters;
            const series = [];
            for (const cls of selectedClasses) {
                const vals = quarters.map(q => (table.quarterMap.get(q) && table.quarterMap.get(q).get(cls)) ? table.quarterMap.get(q).get(cls) : 0);
                series.push({
                    name: cls,
                    values: vals
                });
            }
            const otherVals = quarters.map(q => {
                const cm = table.quarterMap.get(q) || new Map();
                const total = Array.from(cm.values()).reduce((s, v) => s + v, 0);
                let selectedSum = 0;
                for (const cls of selectedClasses) selectedSum += (cm.get(cls) || 0);
                return Math.max(0, total - selectedSum);
            });
            series.push({
                name: 'Other',
                values: otherVals
            });
            const palette = ['#4A90E2', '#50E3C2', '#AAB4C2', '#E94E3D', '#7A8A9F'];
            const traces = series.map((s, idx) => ({
                x: quarters,
                y: s.values,
                name: s.name,
                type: 'bar',
                marker: {
                    color: palette[idx % palette.length]
                }
            }));
            const layout = {
                template: 'plotly_dark',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: {
                    family: 'Inter, sans-serif',
                    color: '#E0E6ED'
                },
                title: {
                    text: 'Revenue class breakdown (stacked) by quarter (USD)',
                    font: {
                        size: 22,
                        color: '#4A90E2'
                    }
                },
                margin: {
                    t: 60,
                    b: 120,
                    l: 80,
                    r: 30
                },
                xaxis: {
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: 'Quarter',
                        font: { color: '#AAB4C2' }
                    }
                },
                yaxis: {
                    showgrid: true,
                    gridcolor: 'rgba(255,255,255,0.05)',
                    color: '#AAB4C2',
                    title: {
                        text: 'USD',
                        font: { color: '#AAB4C2' }
                    }
                },
                barmode: 'stack',
                legend: {
                    orientation: 'v',
                    x: 1.02,
                    y: 1,
                    font: {
                        color: '#E0E6ED'
                    }
                },
                showlegend: traces.length > 1
            };
            Plotly.newPlot(revenueStackEl, traces, layout, {
                responsive: true,
                displayModeBar: true
            });
        }

        function getRevControls() {
            const topInput = document.getElementById('revTopN');
            const thresholdInput = document.getElementById('revThreshold');
            const topN = topInput ? Math.max(1, parseInt(topInput.value || '20', 10)) : 20;
            const threshold = thresholdInput ? Math.max(0, parseFloat(thresholdInput.value || '1')) : 1;
            return {
                topN,
                threshold
            };
        }
        if (revQuarterSelectEl) {
            revQuarterSelectEl.addEventListener('change', () => renderRevenueStack());
        }

        // landing KPIs & diagnostics
        function refreshVisualsAfterConversion() {
            renderLandingKpis();
            populateWorkIncomeSelect();
            if (isViewActive('tsView')) renderTimeSeriesByProvider();
            if (isViewActive('cumView')) renderCumulativeByProvider();
            if (isViewActive('workIncomeView')) renderWorkIncomeChart();
            if (isViewActive('topView')) renderTopWorksFull();
            if (isViewActive('revView')) renderRevenueStack();
        }

        function renderLandingInsights() {
            const container = document.getElementById('landingInsights');
            if (!container) return;
            if (!normalized || normalized.length === 0) {
                container.innerHTML = `
                    <div class="landing-card full-span">
                        <h4>Load your royalty statements</h4>
                        <div class="small">Upload SGAE, ASCAP, or Warner Chappell CSV files to unlock highlights, trends, and diagnostics.</div>
                        <div class="insight-note small">Once data is loaded you will see provider mix, latest quarter performance, and data health here.</div>
                    </div>`;
                return;
            }

            const totalUsd = normalized.reduce((sum, row) => sum + (row.amount || 0), 0);
            const providerTotals = new Map();
            normalized.forEach(row => {
                const provider = row.provider || 'Other';
                const current = providerTotals.get(provider) || 0;
                providerTotals.set(provider, current + (row.amount || 0));
            });
            const providerEntries = Array.from(providerTotals.entries()).sort((a, b) => b[1] - a[1]);
            const maxProviders = 4;
            const topProviders = providerEntries.slice(0, maxProviders);
            const remainingProviders = providerEntries.slice(maxProviders);
            const providerItems = [];
            topProviders.forEach(([provider, value]) => {
                const percent = totalUsd > 0 ? ` · ${formatPercent(value, totalUsd)}` : '';
                providerItems.push(`<li class="insight-pill"><span>${escapeHtml(provider)}</span><span class="muted">${formatCurrency(value)}${percent}</span></li>`);
            });
            if (remainingProviders.length) {
                const otherTotal = remainingProviders.reduce((sum, [, value]) => sum + value, 0);
                const percent = totalUsd > 0 ? ` · ${formatPercent(otherTotal, totalUsd)}` : '';
                providerItems.push(`<li class="insight-pill"><span>Other providers</span><span class="muted">${formatCurrency(otherTotal)}${percent}</span></li>`);
            }
            if (!providerItems.length) {
                providerItems.push('<li class="insight-pill"><span>No provider totals yet</span><span class="muted">Upload data to view mix</span></li>');
            }

            const quarterTotals = new Map();
            normalized.forEach(row => {
                const label = row.quarter && row.quarter !== 'Unknown' ? row.quarter : null;
                if (!label) return;
                const existing = quarterTotals.get(label) || { label, total: 0, date: null };
                existing.total += row.amount || 0;
                if (!existing.date) {
                    const dt = row.quarterDate instanceof Date && !isNaN(row.quarterDate) ? row.quarterDate : quarterLabelToDate(label);
                    if (dt) existing.date = dt;
                }
                quarterTotals.set(label, existing);
            });
            const quarterEntries = Array.from(quarterTotals.values()).sort((a, b) => {
                const aDate = a.date instanceof Date && !isNaN(a.date) ? a.date.getTime() : (quarterLabelToDate(a.label)?.getTime() || 0);
                const bDate = b.date instanceof Date && !isNaN(b.date) ? b.date.getTime() : (quarterLabelToDate(b.label)?.getTime() || 0);
                return aDate - bDate;
            });
            const latestQuarters = quarterEntries.slice(-4).reverse();
            const quarterItems = latestQuarters.length
                ? latestQuarters.map(entry => `<li class="insight-pill"><span>${escapeHtml(entry.label)}</span><span class="muted">${formatCurrency(entry.total)}</span></li>`)
                : ['<li class="insight-pill"><span>No quartered data yet</span><span class="muted">Adjust mappings or add period columns</span></li>'];

            const filesLoaded = fileDiagnostics.length;
            const rowCount = normalized.length;
            const uniqueProviders = providerEntries.map(([provider]) => provider);
            const currencies = Array.from(new Set(normalized.map(row => row.raw_currency).filter(Boolean)));
            const missingDates = normalized.filter(row => !row.quarterDate).length;
            const missingShare = rowCount > 0 ? formatPercent(missingDates, rowCount) : '—';

            container.innerHTML = `
                <div class="landing-card">
                    <h4>Provider mix</h4>
                    <ul class="insight-list">${providerItems.join('')}</ul>
                </div>
                <div class="landing-card">
                    <h4>Latest quarters</h4>
                    <ul class="insight-list">${quarterItems.join('')}</ul>
                </div>
                <div class="landing-card full-span">
                    <h4>Data health</h4>
                    <div class="insight-metric">
                        <span class="label">Files loaded</span>
                        <span class="value">${formatNumber(filesLoaded)}</span>
                    </div>
                    <div class="insight-metric">
                        <span class="label">Rows normalized</span>
                        <span class="value">${formatNumber(rowCount)}</span>
                    </div>
                    <div class="insight-metric">
                        <span class="label">Distinct quarters</span>
                        <span class="value">${quarterEntries.length ? formatNumber(quarterEntries.length) : '—'}</span>
                    </div>
                    <div class="insight-note small">Providers tracked: ${uniqueProviders.length ? escapeHtml(uniqueProviders.join(', ')) : '—'}</div>
                    <div class="insight-note small">Currencies detected: ${currencies.length ? escapeHtml(currencies.join(', ')) : '—'}</div>
                    <div class="insight-note small">Rows missing period: ${missingDates ? `${formatNumber(missingDates)} (${missingShare})` : 'All rows mapped'}</div>
                </div>`;
        }

        function updateDiagnosticsTotals() {
            if (!Array.isArray(fileDiagnostics) || fileDiagnostics.length === 0) return;
            const sourceTotals = new Map();
            const convertedTotals = new Map();
            normalized.forEach(row => {
                if (!row || !row.__source_file) return;
                const key = row.__source_file;
                const sourceVal = Number.isFinite(row.source_amount) ? row.source_amount : 0;
                const usdVal = Number.isFinite(row.amount) ? row.amount : 0;
                sourceTotals.set(key, (sourceTotals.get(key) || 0) + sourceVal);
                convertedTotals.set(key, (convertedTotals.get(key) || 0) + usdVal);
            });
            fileDiagnostics.forEach(diag => {
                if (!diag) return;
                if (sourceTotals.has(diag.file)) diag.fileTotalSource = sourceTotals.get(diag.file);
                if (convertedTotals.has(diag.file)) diag.fileTotalConverted = convertedTotals.get(diag.file);
            });
        }

        function renderLandingKpis() {
            const total = normalized.reduce((s, r) => s + (r.amount || 0), 0);
            const last12 = (() => {
                const validDates = normalized.filter(r => r.distribution_date).map(r => r.distribution_date);
                if (!validDates.length) return 0;
                const maxDate = new Date(Math.max(...validDates.map(d => d.getTime())));
                const from = new Date(maxDate.getFullYear(), maxDate.getMonth() - 11, 1);
                return normalized.filter(r => r.distribution_date && r.distribution_date >= from).reduce((s, r) => s + (r.amount || 0), 0);
            })();
            const top = aggregateTopWorks(normalized, 1);
            const kpiHtml = `
                <div class="kpi-grid">
                    <div class="kpi-card">
                        <div class="kpi-label">Total (USD)</div>
                        <div class="kpi-value">${formatCurrency(total)}</div>
                    </div>
                    <div class="kpi-card">
                        <div class="kpi-label">Last 12 months (USD)</div>
                        <div class="kpi-value">${formatCurrency(last12)}</div>
                    </div>
                    <div class="kpi-card is-wide">
                        <div class="kpi-label">Top work (USD)</div>
                        <div class="kpi-value is-compact">${top.length ? top[0].work_title + ' (' + formatCurrency(top[0].amount) + ')' : '—'}</div>
                    </div>
                </div>`;
            document.getElementById('kpiTiles').innerHTML = kpiHtml;
            renderLandingInsights();
            showDiagnostics();
        }

        function showDiagnostics() {
            const el = document.getElementById('fileList');
            if (!el) return;
            if (!fileDiagnostics || fileDiagnostics.length === 0) {
                el.innerHTML = '<div class="diagnostics-empty">No files loaded yet. Upload statements to review detected mappings.</div>';
                return;
            }
            const rateInfo = `Live EUR→USD: ${liveRates.EUR ? liveRates.EUR.toFixed(4) : 'n/a'} | Live COP→USD: ${liveRates.COP ? liveRates.COP.toFixed(6) : 'n/a'} — Overrides: EUR=${manualRates.EUR ?? 'auto'}, COP=${manualRates.COP ?? 'auto'}`;
            const summary = `<div class="small">Loaded ${fileDiagnostics.length} file(s) — ${formatNumber(rawDataRows.length)} rows total.</div>`;
            const entries = fileDiagnostics.map((d, i) => {
                const headers = Array.isArray(d.headers) ? d.headers : [];
                const mapping = d.mapping || {};
                const providerLabel = d.provider || 'Unknown';
                const providerOverride = d.providerOverride || 'auto';
                const providerCandidates = Array.from(new Set(['ASCAP (Dom)', 'ASCAP (Int)', 'SGAE', 'WARNER CHAPPELL', 'Other', providerLabel].filter(Boolean)));
                const providerOptions = [`<option value="auto"${providerOverride === 'auto' ? ' selected' : ''}>Auto detect (${escapeHtml(providerLabel)})</option>`]
                    .concat(providerCandidates.map(p => `<option value="${escapeAttr(p)}"${providerOverride === p ? ' selected' : ''}>${escapeHtml(p)}</option>`))
                    .join('');
                const renderOptions = (selected, { allowEmpty = false, emptyLabel = 'None', placeholder = null } = {}) => {
                    const opts = [];
                    if (allowEmpty) {
                        opts.push(`<option value=""${!selected ? ' selected' : ''}>${escapeHtml(emptyLabel)}</option>`);
                    } else if (placeholder) {
                        opts.push(`<option value="" disabled${selected ? '' : ' selected'}>${escapeHtml(placeholder)}</option>`);
                    }
                    headers.forEach(h => {
                        opts.push(`<option value="${escapeAttr(h)}"${selected === h ? ' selected' : ''}>${escapeHtml(h)}</option>`);
                    });
                    if (selected && !headers.includes(selected)) {
                        opts.push(`<option value="${escapeAttr(selected)}" selected>${escapeHtml(selected)} (missing)</option>`);
                    }
                    return opts.join('');
                };
                const amountOptions = renderOptions(mapping.amountCol, { placeholder: 'Select column' });
                const dedDisabled = d.provider === 'WARNER CHAPPELL' || d.dedIsAlwaysZero;
                const dedOptions = renderOptions(mapping.dedCol, { allowEmpty: true, emptyLabel: dedDisabled ? 'Not applicable' : 'None' });
                const periodOptions = renderOptions(mapping.periodCol, { allowEmpty: true, emptyLabel: 'Auto / None' });
                const periodYearOptions = renderOptions(mapping.periodYearCol, { allowEmpty: true, emptyLabel: 'Auto / None' });
                const periodQuarterOptions = renderOptions(mapping.periodQuarterCol, { allowEmpty: true, emptyLabel: 'Auto / None' });
                const titleOptions = renderOptions(mapping.titleCol, { allowEmpty: true, emptyLabel: 'Auto / None' });
                const territoryOptions = renderOptions(mapping.territoryCol, { allowEmpty: true, emptyLabel: 'Auto / None' });
                const periodParts = [];
                if (mapping.periodCol) periodParts.push(`date → ${mapping.periodCol}`);
                if (mapping.periodYearCol) periodParts.push(`year → ${mapping.periodYearCol}`);
                if (mapping.periodQuarterCol) periodParts.push(`quarter → ${mapping.periodQuarterCol}`);
                const quarterSourceParts = Array.from(new Set([mapping.periodCol, mapping.periodYearCol, mapping.periodQuarterCol].filter(Boolean)));
                const quarterSourceLabel = quarterSourceParts.length ? quarterSourceParts.join(' + ') : 'Auto';
                const mappingSummary = [
                    `Gross: <strong>${escapeHtml(mapping.amountCol || 'Not set')}</strong>`,
                    `Deduction: <strong>${escapeHtml(mapping.dedCol || (dedDisabled ? 'Not applicable' : 'None'))}</strong>`,
                    `Period: <strong>${escapeHtml(periodParts.length ? periodParts.join(' · ') : 'Auto')}</strong>`,
                    `Title: <strong>${escapeHtml(mapping.titleCol || 'Auto')}</strong>`,
                    `Territory: <strong>${escapeHtml(mapping.territoryCol || 'Auto')}</strong>`,
                    `Quarter source: <strong>${escapeHtml(quarterSourceLabel)}</strong>`
                ].join(' • ');
                const sourceTotal = Number.isFinite(d.fileTotalSource) ? d.fileTotalSource : (Number.isFinite(d.fileTotal) ? d.fileTotal : 0);
                return `
                    <div class="diagnostics-entry">
                        <header>
                            <div>
                                <strong>${escapeHtml(d.file)}</strong>
                                <span class="meta">Detected: ${escapeHtml(providerLabel)}</span>
                            </div>
                            <div class="meta">Rows: ${formatNumber(d.rows)} · Source net: ${formatNumber(sourceTotal)} · USD: ${formatCurrency(d.fileTotalConverted || 0)}</div>
                        </header>
                        <div class="small" style="margin-top:8px">${mappingSummary}</div>
                        <div class="diagnostics-grid">
                            <label>Provider
                                <select id="mappingProvider-${i}" class="diag-select">${providerOptions}</select>
                            </label>
                            <label>Gross column
                                <select id="mappingAmount-${i}" class="diag-select">${amountOptions}</select>
                            </label>
                            <label>Deduction column
                                <select id="mappingDed-${i}" class="diag-select"${dedDisabled ? ' disabled' : ''}>${dedOptions}</select>
                            </label>
                            <label>Period column
                                <select id="mappingPeriod-${i}" class="diag-select">${periodOptions}</select>
                            </label>
                            <label>Distribution year
                                <select id="mappingPeriodYear-${i}" class="diag-select">${periodYearOptions}</select>
                            </label>
                            <label>Distribution quarter
                                <select id="mappingPeriodQuarter-${i}" class="diag-select">${periodQuarterOptions}</select>
                            </label>
                            <label>Title column
                                <select id="mappingTitle-${i}" class="diag-select">${titleOptions}</select>
                            </label>
                            <label>Territory column
                                <select id="mappingTerritory-${i}" class="diag-select">${territoryOptions}</select>
                            </label>
                        </div>
                        <div class="diagnostics-actions">
                            <button onclick="saveMapping(${i})" class="muted">Apply mapping</button>
                            <button onclick="reparseFile(${i})" class="muted">Auto-detect</button>
                        </div>
                    </div>`;
            }).join('');
            el.innerHTML = `${summary}${entries}<div class="diagnostics-note"><strong>Rates:</strong> ${rateInfo}</div>`;
        }

        function saveMapping(idx) {
            const diag = fileDiagnostics[idx];
            if (!diag) return alert('No mapping found for this file.');
            const amountSelect = document.getElementById(`mappingAmount-${idx}`);
            const dedSelect = document.getElementById(`mappingDed-${idx}`);
            const providerSelect = document.getElementById(`mappingProvider-${idx}`);
            const periodSelect = document.getElementById(`mappingPeriod-${idx}`);
            const periodYearSelect = document.getElementById(`mappingPeriodYear-${idx}`);
            const periodQuarterSelect = document.getElementById(`mappingPeriodQuarter-${idx}`);
            const titleSelect = document.getElementById(`mappingTitle-${idx}`);
            const territorySelect = document.getElementById(`mappingTerritory-${idx}`);
            if (!amountSelect) {
                alert('Missing gross column selector.');
                return;
            }
            const amountCol = amountSelect.value;
            if (!amountCol) {
                alert('Please choose a gross column before applying.');
                return;
            }
            const pickValue = (selectEl, fallback = null) => {
                if (!selectEl) return fallback;
                const val = selectEl.value;
                return val === '' ? null : val;
            };
            let dedCol = '';
            if (dedSelect && !dedSelect.disabled) {
                dedCol = dedSelect.value || '';
            } else if (!dedSelect && diag.mapping && diag.mapping.dedCol) {
                dedCol = diag.mapping.dedCol;
            }
            const periodCol = pickValue(periodSelect, diag.mapping ? diag.mapping.periodCol : null);
            const periodYearCol = pickValue(periodYearSelect, diag.mapping ? diag.mapping.periodYearCol : null);
            const periodQuarterCol = pickValue(periodQuarterSelect, diag.mapping ? diag.mapping.periodQuarterCol : null);
            const titleCol = pickValue(titleSelect, diag.mapping ? diag.mapping.titleCol : null);
            const territoryCol = pickValue(territorySelect, diag.mapping ? diag.mapping.territoryCol : null);
            const providerOverride = providerSelect ? providerSelect.value || 'auto' : 'auto';
            diag.providerOverride = providerOverride;
            const rows = rawDataRows.filter(r => r.__source_file === diag.file);
            if (!rows.length) {
                alert('No rows available for this file.');
                return;
            }
            const refreshedHeaders = extractHeadersFromRows(rows);
            if (refreshedHeaders.length) {
                diag.headers = refreshedHeaders;
            }
            const providerCounts = new Map();
            rows.forEach(r => {
                const gross = parseAmountSmart(r[amountCol]);
                const ded = dedCol ? parseAmountSmart(r[dedCol]) : 0;
                const net = Number.isFinite(gross) ? (Number.isFinite(ded) ? gross - ded : gross) : NaN;
                r.__parsed_amount_original = Number.isFinite(net) ? net : NaN;
                const baseProvider = providerOverride === 'auto' ? (diag.provider || 'Other') : providerOverride;
                const resolvedProvider = resolveProviderLabel(baseProvider, r, amountCol, diag.fileTypeHeader);
                providerCounts.set(resolvedProvider, (providerCounts.get(resolvedProvider) || 0) + 1);
                r.__detected_provider = resolvedProvider;
                r.__currency = resolvedProvider === 'SGAE' ? 'EUR' : (resolvedProvider === 'WARNER CHAPPELL' ? 'COP' : 'USD');
                if (titleCol) r.__work_title_candidate = r[titleCol];
                else if (titleCol === null) delete r.__work_title_candidate;
                if (territoryCol) r.__territory_candidate = r[territoryCol];
                else if (territoryCol === null) delete r.__territory_candidate;
                if (periodCol) r.__period_raw = r[periodCol];
                else delete r.__period_raw;
                delete r.__period_date_override;
                delete r.__quarter_override;
                const effectivePeriodCol = periodCol;
                const effectiveYearCol = periodYearCol;
                const effectiveQuarterCol = periodQuarterCol;
                if (resolvedProvider === 'WARNER CHAPPELL' && effectivePeriodCol) {
                    const parsedWarner = parseWarnerPeriod(r[effectivePeriodCol]);
                    if (parsedWarner) {
                        r.__period_date_override = parsedWarner.date;
                        r.__quarter_override = parsedWarner.quarter;
                    }
                } else if (resolvedProvider === 'ASCAP (Dom)') {
                    const parsedAscDom = parseAscDomesticPeriod(
                        effectiveYearCol ? r[effectiveYearCol] : undefined,
                        effectiveQuarterCol ? r[effectiveQuarterCol] : undefined,
                        effectivePeriodCol ? r[effectivePeriodCol] : undefined
                    );
                    if (parsedAscDom) {
                        r.__period_date_override = parsedAscDom.date;
                        r.__quarter_override = parsedAscDom.quarter;
                    }
                }
                r.__mapping = Object.assign({}, r.__mapping, {
                    amountCol,
                    dedCol: dedCol ? dedCol : null,
                    titleCol: titleCol || null,
                    periodCol: periodCol || null,
                    territoryCol: territoryCol || null,
                    periodYearCol: periodYearCol || null,
                    periodQuarterCol: periodQuarterCol || null,
                    provider: resolvedProvider
                });
            });
            const finalProvider = providerCounts.size
                ? Array.from(providerCounts.entries()).sort((a, b) => b[1] - a[1])[0][0]
                : (providerOverride === 'auto' ? (diag.provider || 'Other') : providerOverride);
            const sourceTotal = rows.reduce((sum, row) => sum + (Number.isFinite(row.__parsed_amount_original) ? row.__parsed_amount_original : 0), 0);
            diag.provider = finalProvider;
            diag.mapping = Object.assign({}, diag.mapping, {
                amountCol,
                dedCol: dedCol ? dedCol : null,
                titleCol: titleCol || null,
                periodCol: periodCol || null,
                territoryCol: territoryCol || null,
                periodYearCol: periodYearCol || null,
                periodQuarterCol: periodQuarterCol || null,
                provider: finalProvider
            });
            diag.dedIsAlwaysZero = finalProvider === 'WARNER CHAPPELL';
            showDiagnostics();
            diag.fileTotal = sourceTotal;
            diag.fileTotalSource = sourceTotal;
            normalized = normalizeDataFromCsv(rawDataRows);
            markAllCachesDirty();
            convertCurrenciesToUSD().then(() => {
                refreshVisualsAfterConversion();
                alert('Mapping updated and reprocessed.');
            });
        }
        function reparseFile(idx) {
            const diag = fileDiagnostics[idx];
            if (!diag) return;
            const file = diag.file;
            const rows = rawDataRows.filter(r => r.__source_file === file);
            if (!rows.length) return alert('No rows for file');
            const headers = extractHeadersFromRows(rows);
            const detection = detectProvider(headers);
            const providerGuess = detection.provider;
            diag.fileTypeHeader = detection.fileTypeHeader || diag.fileTypeHeader || null;
            diag.providerOverride = 'auto';
            const headerLookup = new Map();
            const compactLookup = new Map();
            headers.forEach(h => {
                const normalized = h.trim().toLowerCase();
                const compactKey = h.replace(/[\s_]+/g, '').trim().toLowerCase();
                headerLookup.set(normalized, h);
                compactLookup.set(compactKey, h);
            });
            const pickHeader = (...candidates) => {
                for (const cand of candidates) {
                    if (!cand) continue;
                    const normalized = cand.trim().toLowerCase();
                    if (headerLookup.has(normalized)) return headerLookup.get(normalized);
                    const compactKey = cand.replace(/[\s_]+/g, '').trim().toLowerCase();
                    if (compactLookup.has(compactKey)) return compactLookup.get(compactKey);
                }
                return null;
            };
            let amountCol = null,
                dedCol = null,
                titleCol = null,
                periodCol = null,
                territoryCol = null,
                periodYearCol = null,
                periodQuarterCol = null;
            let dedIsAlwaysZero = false;
            if (providerGuess === 'SGAE') {
                amountCol = pickHeader(SGAE_HEADERS.GROSS) || headers[0];
                dedCol = pickHeader(SGAE_HEADERS.DEDUCTION);
                titleCol = pickHeader(SGAE_HEADERS.WORK_TITLE);
                periodCol = pickHeader(SGAE_HEADERS.PERIOD);
            } else if (providerGuess === 'WARNER CHAPPELL') {
                amountCol = pickHeader(
                    'amount_paid_less_tax',
                    'amount_paid_less_taxes',
                    'amount_paid_less_tax_local',
                    'amount_paid_less_tax_loc_curr',
                    'amount_paid'
                ) || headers.find(h => /amount|paid|net|royalty/i.test(h)) || headers[0];
                dedCol = null;
                titleCol = pickHeader('tango_work_title', 'tango_work_code', 'work_title', 'title');
                periodCol = pickHeader(
                    'royalty_period',
                    'royalty period',
                    'royalty_period_description',
                    'royalty_period_desc',
                    'period'
                );
                territoryCol = pickHeader('source_territory_name', 'processing_territory_name');
                dedIsAlwaysZero = true;
            } else if (providerGuess === 'ASCAP (Dom)') {
                amountCol = pickHeader('Dollars', 'Dollar Amount', 'Net Amount', 'Net Amount USD', 'Net Royalty', 'Net USD', 'Amount Paid', 'Gross Amount') || headers.find(h => /amount|total|usd|net/i.test(h)) || headers[0];
                dedCol = headers.find(h => /dto|administr|admin|deduc|descuento/i.test(h)) || null;
                titleCol = headers.find(h => /title|obra|work|tit/i.test(h));
                periodYearCol = pickHeader('Distribution Year', 'DistributionYear', 'Royalty Year', 'Year');
                periodQuarterCol = pickHeader('Distribution Quarter', 'DistributionQuarter', 'Royalty Quarter', 'Quarter');
                periodCol = headers.find(h => /period|peri|date|fecha/i.test(h));
                if (!periodCol) periodCol = periodQuarterCol || periodYearCol;
            } else {
                amountCol = headers.find(h => /amount|importe|monto|total|usd|net/i.test(h)) || headers[0];
                dedCol = headers.find(h => /dto|administr|admin|deduc|descuento/i.test(h)) || null;
                titleCol = headers.find(h => /title|obra|work|tit/i.test(h)) || null;
                periodCol = headers.find(h => /period|peri|date|fecha/i.test(h)) || null;
            }
            if (!amountCol) amountCol = headers[0];
            const providerCounts = new Map();
            rows.forEach(r => {
                const gross = parseAmountSmart(r[amountCol]);
                const ded = dedIsAlwaysZero ? 0 : (dedCol ? parseAmountSmart(r[dedCol]) : 0);
                const net = Number.isFinite(gross) ? (Number.isFinite(ded) ? gross - ded : gross) : NaN;
                r.__parsed_amount_original = Number.isFinite(net) ? net : NaN;
                if (periodCol) r.__period_raw = r[periodCol];
                else delete r.__period_raw;
                delete r.__period_date_override;
                delete r.__quarter_override;
                if (titleCol) r.__work_title_candidate = r[titleCol];
                if (territoryCol) r.__territory_candidate = r[territoryCol];
                else delete r.__territory_candidate;
                const resolvedProvider = resolveProviderLabel(providerGuess, r, amountCol, diag.fileTypeHeader);
                providerCounts.set(resolvedProvider, (providerCounts.get(resolvedProvider) || 0) + 1);
                r.__detected_provider = resolvedProvider;
                r.__currency = resolvedProvider === 'SGAE' ? 'EUR' : (resolvedProvider === 'WARNER CHAPPELL' ? 'COP' : 'USD');
                if (resolvedProvider === 'WARNER CHAPPELL' && periodCol) {
                    const parsedWarner = parseWarnerPeriod(r[periodCol]);
                    if (parsedWarner) {
                        r.__period_date_override = parsedWarner.date;
                        r.__quarter_override = parsedWarner.quarter;
                    }
                } else if (resolvedProvider === 'ASCAP (Dom)') {
                    const parsedAscDom = parseAscDomesticPeriod(
                        periodYearCol ? r[periodYearCol] : undefined,
                        periodQuarterCol ? r[periodQuarterCol] : undefined,
                        periodCol ? r[periodCol] : undefined
                    );
                    if (parsedAscDom) {
                        r.__period_date_override = parsedAscDom.date;
                        r.__quarter_override = parsedAscDom.quarter;
                    }
                }
                r.__mapping = {
                    amountCol,
                    dedCol: dedIsAlwaysZero ? null : (dedCol || null),
                    titleCol: titleCol || null,
                    periodCol: periodCol || null,
                    territoryCol: territoryCol || null,
                    periodYearCol: periodYearCol || null,
                    periodQuarterCol: periodQuarterCol || null,
                    provider: resolvedProvider
                };
            });
            const finalProvider = providerCounts.size
                ? Array.from(providerCounts.entries()).sort((a, b) => b[1] - a[1])[0][0]
                : providerGuess;
            const sourceTotal = rows.reduce((sum, row) => sum + (Number.isFinite(row.__parsed_amount_original) ? row.__parsed_amount_original : 0), 0);
            diag.provider = finalProvider;
            diag.mapping = {
                amountCol,
                dedCol: dedIsAlwaysZero ? null : (dedCol || null),
                titleCol: titleCol || null,
                periodCol: periodCol || null,
                territoryCol: territoryCol || null,
                periodYearCol: periodYearCol || null,
                periodQuarterCol: periodQuarterCol || null,
                provider: finalProvider
            };
            diag.dedIsAlwaysZero = dedIsAlwaysZero;
            diag.headers = headers;
            diag.fileTotal = sourceTotal;
            diag.fileTotalSource = sourceTotal;
            showDiagnostics();
            normalized = normalizeDataFromCsv(rawDataRows);
            markAllCachesDirty();
            convertCurrenciesToUSD().then(() => {
                refreshVisualsAfterConversion();
                alert('Re-detection done.');
            });
        }
        function formatCurrency(v) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                maximumFractionDigits: 2
            }).format(v);
        }

        function formatPercent(value, total) {
            if (!Number.isFinite(value) || !Number.isFinite(total) || total === 0) return '—';
            const pct = (value / total) * 100;
            const digits = pct >= 10 ? 1 : 2;
            return `${pct.toFixed(digits)}%`;
        }

        function formatNumber(v) {
            return Number.isFinite(v) ? v.toLocaleString() : '—';
        }

        function escapeHtml(value) {
            return String(value ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function escapeAttr(value) {
            return escapeHtml(value);
        }

        function setupPlotDownload(buttonOrId, targetOrId, fileName, size, shouldSkip) {
            const button = typeof buttonOrId === 'string' ? document.getElementById(buttonOrId) : buttonOrId;
            const target = typeof targetOrId === 'string' ? document.getElementById(targetOrId) : targetOrId;
            if (!button || !target) return;
            button.addEventListener('click', () => {
                if (shouldSkip && shouldSkip()) return;
                const height = size && typeof size.height === 'number' ? size.height : 700;
                const width = size && typeof size.width === 'number' ? size.width : 1000;
                Plotly.toImage(target, {
                    format: 'png',
                    height,
                    width
                }).then(url => {
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                });
            });
        }

        function populateRevQuarter() {
            if (!revQuarterSelectEl) return;
            revQuarterSelectEl.innerHTML = '';
            const table = buildRevenueTable();
            if (!table.quarters) return;
            table.quarters.forEach(q => {
                const opt = document.createElement('option');
                opt.value = q;
                opt.text = q;
                revQuarterSelectEl.appendChild(opt);
            });
            if (table.quarters.length) {
                revQuarterSelectEl.value = table.quarters[table.quarters.length - 1];
            }
        }

        setupPlotDownload('downloadTS', timeSeriesEl, 'time_series_by_provider.png', { height: 700, width: 1000 });
        setupPlotDownload('downloadCum', cumulativeEl, 'cumulative_by_provider.png', { height: 700, width: 1000 });
        setupPlotDownload(downloadWorkIncomeBtn, workIncomeChartEl, 'work_income_over_time.png', { height: 700, width: 1000 }, () => downloadWorkIncomeBtn && downloadWorkIncomeBtn.disabled);
        setupPlotDownload('downloadTop', topWorksEl, 'top_10_works.png', { height: 900, width: 1200 });
        setupPlotDownload('downloadRev', revenueStackEl, 'revenue_classes.png', { height: 900, width: 1200 });

        // start
        showView('landingView');
    </script>
</body>


</html>
